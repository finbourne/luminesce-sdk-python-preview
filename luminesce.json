{
  "openapi": "3.0.1",
  "info": {
    "title": "FINBOURNE Luminesce Web API",
    "termsOfService": "https://www.finbourne.com/legal/terms-conditions",
    "contact": {
      "name": "FINBOURNE Technology",
      "url": "https://www.finbourne.com",
      "email": "info@finbourne.com"
    },
    "version": "1.15.161",
    "x-logo": {
      "url": "https://www.lusid.com/app/assets/logo_white.png",
      "backgroundColor": "#415464"
    },
    "description": "FINBOURNE Technology"
  },
  "servers": [
    {
      "url": "https://www.lusid.com/honeycomb"
    }
  ],
  "paths": {
    "/api/Catalog": {
      "get": {
        "tags": [
          "Current Table/Field Catalog"
        ],
        "summary": "GetCatalog: Shows Table and Field level information on Providers that are currently running that you have access to (in Json format)",
        "description": "\nThe following LuminesceSql is executed to return this information:\n\n```sql\n@reg =\nselect\n    Name,\n    min(Description) as Description,\n    min(DocumentationLink) as DocumentationLink,\n    iif(Category = 'View' and Client is not null, true, false) as IsView\nfrom\n    Sys.Registration\nwhere\n    Type in ('DirectProvider', 'DataProvider')\n    and \n    ShowAll = false\ngroup by\n    1\n    ;\n\n@fld =\nselect\n    TableName,\n    FieldName,\n    DataType,\n    FieldType,\n    IsPrimaryKey,\n    IsMain,\n    Description,\n    ParamDefaultValue,\n    TableParamColumns\nfrom\n    Sys.Field\n    ;\n\n@x =\nselect\n    coalesce(f.TableName, r.Name) as TableName,\n    coalesce(f.FieldName, 'N/A') as FieldName,\n    f.DataType,\n    f.FieldType,\n    f.IsPrimaryKey,\n    f.IsMain,\n    case \n        when f.TableName is not null then\n            f.Description\n        else\n            r.Name || ' returns a different set of columns depending on use.'\n        end as Description,\n    f.ParamDefaultValue,\n    f.TableParamColumns,\n    r.Description as ProviderDescription,\n    r.DocumentationLink,\n    r.IsView\nfrom\n    @reg r\n    left outer join @fld f\n        on r.Name = f.TableName\norder by\n    1, 5 desc, 6 desc, 2\n    ;\n   \n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetCatalog",
        "parameters": [
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Limit the catalog to only things in some way dealing with the passed in text string",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Certificate/certificate": {
      "get": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] DownloadCertificate: Downloads your latest Domain or User certificate's public or private key - if any",
        "description": "\nDownloads your latest Domain or User certificate's public or private key - if any.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - certificate is not available for some reason\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "DownloadCertificate",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "User or Domain level cert (Domain level requires additional entitlements)",
            "schema": {
              "$ref": "#/components/schemas/CertificateType"
            },
            "x-nullable": true
          },
          {
            "name": "fileType",
            "in": "query",
            "description": "Should the public key or private key be downloaded? (both must be in place to run providers)",
            "schema": {
              "$ref": "#/components/schemas/CertificateFileType"
            },
            "x-nullable": true
          },
          {
            "name": "mayAutoCreate",
            "in": "query",
            "description": "If no matching cert is available, should an attempt be made to Create/Renew it with default options?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Certificate/certificates": {
      "get": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] ListCertificates: Lists all the certificates previously minted to which you have access",
        "description": "\nLists all the certificates previously minted to which you have access.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "ListCertificates",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Certificate/manage": {
      "put": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] ManageCertificate: Manages a new certificate (Create / Renew / Revoke)",
        "description": "\nManages a certificate.  This could be creating a new one, renewing an old one or revoking one explicitly.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something about the request cannot be processed\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "ManageCertificate",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "The Action to perform, e.g. Create / Renew / Revoke",
            "schema": {
              "$ref": "#/components/schemas/CertificateAction"
            },
            "x-nullable": true
          },
          {
            "name": "type",
            "in": "query",
            "description": "User or Domain level cert (Domain level requires additional entitlements)",
            "schema": {
              "$ref": "#/components/schemas/CertificateType"
            },
            "x-nullable": true
          },
          {
            "name": "version",
            "in": "query",
            "description": "Version number of the cert, the request will fail to validate if incorrect",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1
            },
            "x-nullable": true
          },
          {
            "name": "validityStart",
            "in": "query",
            "description": "When should the cert first be valid (defaults to the current time in UTC)",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "validityEnd",
            "in": "query",
            "description": "When should the cert no longer be valid (defaults to 13 months from now)",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "True will just validate the request, but perform no changes to any system",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Download/download": {
      "get": {
        "tags": [
          "Binary Downloading"
        ],
        "summary": "[EXPERIMENTAL] DownloadBinary: Downloads the latest version (or specific if needs be) of the specified Luminesce Binary, given the required entitlements.",
        "description": "\nDownloads the latest version (or specific if needs be) of the specified Luminesce Binary, given the required entitlements.\n\n*NOTE:* This endpoint is an alternative to time-consuming manual distribution via Drive or Email.\n> it relies on as underlying datastore that is not quite as \"Highly Available\" to the degree \n> that FINBOURNE services generally are.  \n> Thus it is not subject to the same SLAs as other API endpoints are.\n> *If you perceive an outage, please try again later.*\n\nOnce a file has been downloaded the following steps can be used to install it (for the dotnet tools at least):\n\n1. Open a terminal and cd to the directory you downloaded it to\n2. Install / extract files from that package via:\n```\ndotnet tool install NameOfFileWithoutVersionNumberOrExtension -g --add-source \".\"\n```\ne.g.\n```\ndotnet tool install Finbourne.Luminesce.DbProviders.Oracle_Snowflake -g --add-source \".\"\n```\n3. Execute them (see documentation for specific binary)...\n\nThe installed binaries can then be found in\n- Windows - `%USERPROFILE%\\.dotnet\\tools\\.store\\`\n- Linux/macOS - `$HOME/.dotnet/tools/.store/`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - binary file is not available for some reason (e.g. permissions or invalid version)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "DownloadBinary",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Type of binary to download (each requires separate licenses and entitlements)",
            "schema": {
              "$ref": "#/components/schemas/LuminesceBinaryType"
            },
            "x-nullable": true
          },
          {
            "name": "version",
            "in": "query",
            "description": "An explicit version of the binary.  Leave blank to get the latest version (recommended)",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The .nupkg file of the requested binary",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/History": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetHistory: Shows queries executed in a given historical time window (in Json format).",
        "description": "\nStarts to load the historical query logs for a certain time range, search criteria, etc.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetHistory",
        "parameters": [
          {
            "name": "startAt",
            "in": "query",
            "description": "Date time to start the search from.  Will default to Now - 1 Day",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "Date time to end the search at.  Defaults to now.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Some test that must be in at least one field returned.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "showAll",
            "in": "query",
            "description": "For users with extra permissions, they may optionally see other users' queries.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "mayUseNativeStore",
            "in": "query",
            "description": "Should a native data store (e.g. Athena or Fabric) be used over Elastic Search if available?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetProgressOfHistory: View progress information (up until this point) of a history query",
        "description": "View progress information (up until this point) of previously started History query\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/histogram": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/json": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format.",
        "description": "Fetch the data in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/metadata/access/resources": {
      "get": {
        "tags": [
          "Application Metadata"
        ],
        "summary": "GetServicesAsAccessControlledResources: Get resources available for access control",
        "description": "\nGet the comprehensive set of resources that are available for access control.\n\nThe following LuminesceSql is executed to return this information, \nwhich is then packaged up as AccessControlledResource:\n\n```sql\nselect\n    Name,\n    min(coalesce(Description, Name) || ' (' || Type || ')') as Description\nfrom\n    Sys.Registration\nwhere\n    Type in ('DirectProvider', 'DataProvider')\n    and\n    ShowAll = true\ngroup by 1\norder by 1\n   \n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetServicesAsAccessControlledResources",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground": {
      "put": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "StartQueries: Starts to Execute the LuminesceSql statements in the background.",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis\n- view progress information (up until this point), for all results in one go\n- cancel the queries (if still running) / clear the data (if already returned)\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "StartQueries",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "An enum value defining the set of statements being executed",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MultiQueryDefinitionType"
            },
            "example": "Instrument"
          },
          {
            "name": "asAt",
            "in": "query",
            "description": "The AsAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "effectiveAt",
            "in": "query",
            "description": "The EffectiveAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "limit1",
            "in": "query",
            "description": "A limit that is applied to first-level queries (e.g. Instruments themselves)",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-nullable": true
          },
          {
            "name": "limit2",
            "in": "query",
            "description": "A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found)",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-nullable": true
          },
          {
            "name": "input1",
            "in": "query",
            "description": "A value available to queries, these vary by 'type' and are only used by some types at all.\r\ne.g. a start-date of some sort",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "input2",
            "in": "query",
            "description": "A second value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "input3",
            "in": "query",
            "description": "A third value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 1200s (20m)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 1200,
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 7200,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "A \"search\" value (e.g. 'Apple' on an instrument search, a `Finbourne.Filtering` expression of Insights, etc.)\r\nIn the cases where \"Nothing\" is valid for a `Finbourne.Filtering` expression, pass `True`.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "Apple"
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground/{executionId}": {
      "get": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set",
        "description": "View progress information (up until this point) for the entire query-set\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set",
        "description": "Cancel the query-set (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryCsv",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryCsv",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryExcel",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryExcel",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/fromdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutQueryDesignToSql: Generates SQL from a structured query design",
        "description": "SQL Designer specification to generate SQL from",
        "operationId": "PutQueryDesignToSql",
        "requestBody": {
          "description": "Structured Query design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromfilereaddesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutFileReadDesignToSql: Generates file read SQL from a structured query design",
        "description": "SQL Designer specification to generate SQL from",
        "operationId": "PutFileReadDesignToSql",
        "parameters": [
          {
            "name": "executeQuery",
            "in": "query",
            "description": "Should the generated query be executed to build preview data or determine errors.>",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "Structured file read design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromviewdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutViewDesignToSql: Generates view creation sql from a structured view creation design",
        "description": "Converts a ConvertToView specification into SQL that creates a view",
        "operationId": "PutViewDesignToSql",
        "requestBody": {
          "description": "Structured Query design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromwriterdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutWriterDesignToSql: Generates writer SQL from a valid writer-design structure",
        "description": "SQL Writer Design specification to generate Writer SQL from",
        "operationId": "PutWriterDesignToSql",
        "requestBody": {
          "description": "Structured Writer Design design object to generate Writer SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/intellisense": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutIntellisense: Generate a set of possible intellisense prompts given a SQL snip-it (in need not yet be valid) and cursor location",
        "description": "SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.",
        "operationId": "PutIntellisense",
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/intellisenseError": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutIntellisenseError: Generate a set of error ranges, if any, in the given SQL (expressed as Lines)",
        "description": "SQL (by line) to syntax check and return error ranges from within, if any.",
        "operationId": "PutIntellisenseError",
        "requestBody": {
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/json": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryJson",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/json/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryJson",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/parquet": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryParquet: Executes Sql, returned in Parquet format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryParquet",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/parquet/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryParquet: Executes Sql, returned in Parquet (.parquet) format (as a file to be downloaded) format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryParquet",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryPipe",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryPipe",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pretty": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "PutQueryToFormat: Formats SQL into a more readable form, a.k.a. Pretty-Print the SQL.",
        "description": "\nThis formats SQL (given a set of options as to how to do so).\nIt takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly)\nand returns the reformatted version.\ne.g.\n```sql\nselect x,y,z from a inner join b on a.x=b.x where x>y or y!=z\n```\nbecomes\n```sql\nselect x, y, z\nfrom a\ninner join b\n   on a.x = b.x\nwhere x > y\n   or y != z\n```\n",
        "operationId": "PutQueryToFormat",
        "parameters": [
          {
            "name": "trailingCommas",
            "in": "query",
            "description": "Should commas be after an expression (as opposed to before)",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "uppercaseKeywords",
            "in": "query",
            "description": "Should key words be capitalized",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "breakJoinOnSections",
            "in": "query",
            "description": "Should clauses on joins be given line breaks?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "spaceAfterExpandedComma",
            "in": "query",
            "description": "Should comma-lists have spaces after the commas?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "keywordStandardization",
            "in": "query",
            "description": "Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCommaLists",
            "in": "query",
            "description": "Should comma-lists (e.g. select a,b,c) have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandInLists",
            "in": "query",
            "description": "Should IN-lists have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandBooleanExpressions",
            "in": "query",
            "description": "Should boolean expressions have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandBetweenConditions",
            "in": "query",
            "description": "Should between conditions have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCaseStatements",
            "in": "query",
            "description": "Should case-statements have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "maxLineWidth",
            "in": "query",
            "description": "Maximum number of characters to allow on one line (if possible)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 120
            },
            "x-nullable": true
          },
          {
            "name": "spaceBeforeTrailingSingleLineComments",
            "in": "query",
            "description": "Should the be a space before trailing single line comments?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "multilineCommentExtraLineBreak",
            "in": "query",
            "description": "Should an additional line break be added after multi-line comments?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQuerySqlite",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQuerySqlite",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/todesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToQueryDesign: Generates a SQL-design object from SQL string, if possible.",
        "description": "SQL to attempt to create a Design object from",
        "operationId": "PutSqlToQueryDesign",
        "parameters": [
          {
            "name": "validateWithMetadata",
            "in": "query",
            "description": "Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "SELECT\n    [TableName],\n    Count(distinct [FieldName]) as [NumberOfFields]\nFROM\n    [Sys.Field]\nWHERE\n    ([TableName] = 'Sys.Registration')\nGROUP BY\n    [TableName]\nORDER BY\n    [DataType]\nLIMIT 42"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/tofilereaddesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToFileReadDesign: Generates a SQL-file-read-design object from SQL string, if possible.",
        "description": "SQL to attempt to create a Design object from",
        "operationId": "PutSqlToFileReadDesign",
        "parameters": [
          {
            "name": "determineAvailableSources",
            "in": "query",
            "description": "Should the available sources be determined from `Sys.Registration`",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the file read design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "@x = \nuse Drive.Csv\n  --file=/some/folder/somefile.csv\nenduse;\n\nselect * from @x;"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/toviewdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToViewDesign: Generates a structured view creation design from existing view creation SQL.",
        "description": "SQL which creates a view into a structured ConvertToViewData object",
        "operationId": "PutSqlToViewDesign",
        "requestBody": {
          "description": "SQL Query to generate the ConvertToViewData object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "@x = \nuse Sys.Admin.SetupView\n  --provider=YourView\n----\nselect * from Lusid.Instrument\nenduse;\n\nselect * from @x;"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/towriterdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToWriterDesign: Generates a SQL-writer-design object from SQL string, if possible.",
        "description": "SQL to attempt to create a Writer Design object from",
        "operationId": "PutSqlToWriterDesign",
        "parameters": [
          {
            "name": "mergeAdditionalMappingFields",
            "in": "query",
            "description": "Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the writer design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "Select abc from xyz"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/xml": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryXml: Executes Sql, returned in Xml format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryXml",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/xml/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryXml: Executes Sql, returned in Xml format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryXml",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground": {
      "put": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "StartQuery: Starts to Execute LuminesceSql in the background.",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\n- view progress information (up until this point)\n- cancel the query (if still running) / clear the data (if already returned)\n\nThis can still error on things like an outright syntax error, but more runtime errors (e.g. from providers) will not\ncause this to error (that will happen when attempting to fetch data)\n\nHere is an example that intentionally takes one minute to run:\n\n```sql\nselect Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120\n```\n\nThis is the only place in the Luminesce WebAPI where the following is supported.\nThis will allow for the same user running a character-identical query not kick off a new query but simply be returned a reference \nto the already running one for up to `N` seconds (where `N` should be `<=` `keepForSeconds`).\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "StartQuery",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "A name for this query.  This goes into logs and is available in `Sys.Logs.HcQueryStart`.",
            "schema": {
              "type": "string"
            },
            "example": "Intentionally slow test query"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 7200 (2h)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 1200,
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 7200,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "The LuminesceSql query to kick off.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120"
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "GetProgressOf: View progress information (up until this point)",
        "description": "View progress information (up until this point)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOf",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "CancelQuery: Cancels (if running) or clears the data from (if completed) a previously started query",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/csv": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultCsv: Fetches the result from a previously started query, in CSV format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultCsv",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/excel": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultExcel: Fetches the result from a previously started query, in Excel format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultExcel",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/histogram": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestampFieldName",
            "in": "query",
            "description": "Name of the timestamp field used in building the histogram",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startAt",
            "in": "query",
            "description": "Start point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "End point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/json": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJson: Fetches the result from a previously started query, in JSON string format.\r\nPlease move to '/jsonProper' instead.  This may be marked as Deprecated in the future.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/jsonProper": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJsonProper: Fetches the result from a previously started query, in JSON format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJsonProper",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/parquet": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultParquet: Fetches the result from a previously started query, in Parquet format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultParquet",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/pipe": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultPipe: Fetches the result from a previously started query, in pipe-delimited format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultPipe",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/sqlite": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultSqlite: Fetches the result from a previously started query, in SqLite format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultSqlite",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/xml": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultXml: Fetches the result from a previously started query, in Xml format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultXml",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    }
  },
  "components": {
    "schemas": {
      "AccessControlledAction": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "action": {
            "$ref": "#/components/schemas/ActionId"
          },
          "limitedSet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdSelectorDefinition"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResource": {
        "type": "object",
        "properties": {
          "application": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledAction"
            },
            "nullable": true
          },
          "identifierParts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResourceIdentifierPartSchemaAttribute"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResourceIdentifierPartSchemaAttribute": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "required": {
            "type": "boolean"
          },
          "valuesPath": {
            "type": "string",
            "nullable": true
          },
          "typeId": {
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ActionId": {
        "required": [
          "activity",
          "entity",
          "scope"
        ],
        "type": "object",
        "properties": {
          "scope": {
            "maxLength": 100,
            "minLength": 3,
            "type": "string"
          },
          "activity": {
            "maxLength": 25,
            "minLength": 3,
            "type": "string"
          },
          "entity": {
            "maxLength": 25,
            "minLength": 3,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AggregateFunction": {
        "enum": [
          "count",
          "count_distinct",
          "sum",
          "total",
          "avg",
          "min",
          "max",
          "group_concat"
        ],
        "type": "string",
        "description": "Aggregation function type"
      },
      "Aggregation": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AggregateFunction"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias, if any, for the Aggregate expression when selected",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "How to aggregate over a field"
      },
      "AutoDetectType": {
        "enum": [
          "Auto",
          "SpecifyColumnsYetInferTypes",
          "SpecifyColumnsAndTypes"
        ],
        "type": "string",
        "description": "The method of name/type column inference being used"
      },
      "AvailableField": {
        "required": [
          "fieldType",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the Field"
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "fieldType": {
            "$ref": "#/components/schemas/FieldType"
          },
          "isMain": {
            "type": "boolean",
            "description": "Is this a Main Field within the Provider",
            "nullable": true
          },
          "isPrimaryKey": {
            "type": "boolean",
            "description": "Is this a member of the PrimaryKey of the Provider",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "AvailableParameter": {
        "required": [
          "fields",
          "parameterName",
          "providerName"
        ],
        "type": "object",
        "properties": {
          "providerName": {
            "minLength": 1,
            "type": "string",
            "description": "Name of the Provider with a TableParameter"
          },
          "parameterName": {
            "minLength": 1,
            "type": "string",
            "description": "Name of the TableParameter on the Provider"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MappableField"
            },
            "description": "Fields that can be mapped to"
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "BackgroundMultiQueryProgressResponse": {
        "type": "object",
        "properties": {
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundMultiQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "format": "uuid",
            "readOnly": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json (as a string) data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchJsonProper": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json-proper data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchXml": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Xml data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchParquet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Parquet data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchCsv": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "CSV data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchPipe": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Pipe delimited data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchExcel": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Excel workbook data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchSqlite": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "SqLite DB data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Histogram links for all of the child queries",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryCancelResponse": {
        "type": "object",
        "properties": {
          "hadData": {
            "type": "boolean"
          },
          "previousStatus": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "previousState": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryProgressResponse": {
        "type": "object",
        "properties": {
          "hasData": {
            "type": "boolean",
            "description": "Is there currently data for this Query?"
          },
          "rowCount": {
            "type": "integer",
            "description": "Number of rows of data held. -1 if none as yet.",
            "format": "int32"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "state": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "The LuminesceSql of the original request",
            "nullable": true
          },
          "queryName": {
            "type": "string",
            "description": "The QueryName given in the original request",
            "nullable": true
          },
          "columnsAvailable": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Column"
            },
            "description": "When HasData is true this is the schema of columns that will be returned if the data is requested",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "description": "ExecutionId of the started-query",
            "nullable": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJsonProper": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchXml": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchParquet": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchCsv": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchPipe": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchExcel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchSqlite": {
            "$ref": "#/components/schemas/Link"
          },
          "histogram": {
            "$ref": "#/components/schemas/Link"
          }
        },
        "additionalProperties": false,
        "description": "Response for Background Query Start requests"
      },
      "BackgroundQueryState": {
        "enum": [
          "New",
          "Running",
          "Errored",
          "Cancelled",
          "Executed",
          "ExecutedNoSerializationRequired",
          "Serialized",
          "SerializationFailed",
          "AttemptingToDeserialize",
          "Loaded",
          "Cleared",
          "Disposed"
        ],
        "type": "string"
      },
      "CertificateAction": {
        "enum": [
          "Create",
          "CreateAndAllowMultipleWhichAreValid",
          "Renew",
          "Revoke"
        ],
        "type": "string",
        "description": "The action to take with a certificate"
      },
      "CertificateFileType": {
        "enum": [
          "Public",
          "Private"
        ],
        "type": "string",
        "description": "The type of the certificate file to be downloaded (both public and private are needed to connect)"
      },
      "CertificateState": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The \"key\" to which this belongs in the dictionary,\r\nbasically the CN without any version information",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "description": "The version of this certificate",
            "format": "int32"
          },
          "commonName": {
            "type": "string",
            "description": "The common Name of the Certificate",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/CertificateType"
          },
          "creationStatus": {
            "$ref": "#/components/schemas/CertificateStatus"
          },
          "revocationStatus": {
            "$ref": "#/components/schemas/CertificateStatus"
          },
          "validityStart": {
            "type": "string",
            "description": "The earliest point at which a certificate can be used",
            "format": "date-time",
            "nullable": true
          },
          "validityEnd": {
            "type": "string",
            "description": "The latest point at which a certificate can be used",
            "format": "date-time",
            "nullable": true
          },
          "revokedAt": {
            "type": "string",
            "description": "The point at which this was revoked, if any",
            "format": "date-time",
            "nullable": true
          },
          "revokedBy": {
            "type": "string",
            "description": "The user which revoked this, if any",
            "nullable": true
          },
          "createdAt": {
            "type": "string",
            "description": "The point at which this was created",
            "format": "date-time",
            "nullable": true
          },
          "createdBy": {
            "type": "string",
            "description": "The user which created this",
            "nullable": true
          },
          "serialNumber": {
            "type": "string",
            "description": "The Vault-issued serial number of the certificate, if any - used for revocation",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "The location within Configuration Store that this is saved to",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information held about the minting / revoking of a certificate.\r\nIt does *not* contain the certificate itself"
      },
      "CertificateStatus": {
        "enum": [
          "None",
          "WebApiPersistence",
          "Vault",
          "Rabbit",
          "ConfigStore",
          "AllSystems"
        ],
        "type": "string",
        "description": "Which System(s) have been updated with a given request"
      },
      "CertificateType": {
        "enum": [
          "Domain",
          "User"
        ],
        "type": "string",
        "description": "The sort of certificate being Created / Revoked / Renewed"
      },
      "Column": {
        "type": "object",
        "properties": {
          "isPrimaryKey": {
            "type": "boolean"
          },
          "isMain": {
            "type": "boolean"
          },
          "isRequiredByProvider": {
            "type": "boolean"
          },
          "mandatoryForActions": {
            "type": "string",
            "nullable": true
          },
          "clientIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "conditionUsage": {
            "$ref": "#/components/schemas/ConditionAttributes"
          },
          "sampleValues": {
            "type": "string",
            "nullable": true
          },
          "allowedValues": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ColumnInfo": {
        "type": "object",
        "properties": {
          "select": {
            "type": "boolean",
            "description": "Should the column be used/selected?"
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The name of the column",
            "nullable": true
          },
          "xPath": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Xpath for the column (only applicable to XML defined columns)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "ConditionAttributes": {
        "enum": [
          "None",
          "Normal",
          "Required",
          "Main"
        ],
        "type": "string"
      },
      "ConvertToViewData": {
        "required": [
          "name",
          "query"
        ],
        "type": "object",
        "properties": {
          "query": {
            "minLength": 1,
            "type": "string",
            "description": "view query"
          },
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of view"
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Description of view",
            "nullable": true
          },
          "documentationLink": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Documentation link",
            "nullable": true
          },
          "viewParameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ViewParameter"
            },
            "description": "View parameters",
            "nullable": true
          },
          "otherParameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "description": "Other parameters not explicitly handled by the ConvertToView generation.\r\nThese will be populated by the \"From SQL\" and should simply be returned by\r\nthe web GUI should the user edit / update / regenerate",
            "nullable": true
          },
          "startingVariableName": {
            "type": "string",
            "description": "Which variable the this start with, null if not started from a full Create View Sql Statement.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of view data where will template the data into a 'create view' sql"
      },
      "CursorPosition": {
        "required": [
          "column",
          "row"
        ],
        "type": "object",
        "properties": {
          "row": {
            "type": "integer",
            "description": "Row (0 based) of the user's cursor position",
            "format": "int32"
          },
          "column": {
            "type": "integer",
            "description": "Column (0 based) of the user's cursor position",
            "format": "int32"
          }
        },
        "additionalProperties": false,
        "description": "Represents a cursor location"
      },
      "DataType": {
        "enum": [
          "Boolean",
          "Date",
          "DateTime",
          "Decimal",
          "Double",
          "Int",
          "BigInt",
          "Text",
          "Table"
        ],
        "type": "string"
      },
      "ErrorHighlightItem": {
        "required": [
          "length",
          "message",
          "start",
          "stop"
        ],
        "type": "object",
        "properties": {
          "start": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "stop": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "noViableAlternativeStart": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "length": {
            "type": "integer",
            "description": "The length of the error token counting line breaks if any",
            "format": "int32"
          },
          "message": {
            "minLength": 1,
            "type": "string",
            "description": "The error message"
          }
        },
        "additionalProperties": false,
        "description": "Representation of a sql error"
      },
      "ErrorHighlightRequest": {
        "required": [
          "lines"
        ],
        "type": "object",
        "properties": {
          "lines": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The lines of text the user currently has in the editor"
          },
          "ensureSomeTextIsSelected": {
            "type": "boolean",
            "description": "If an editor requires some selection of non-whitespace this can be set to true to force\r\nat least one visible character to be selected."
          }
        },
        "additionalProperties": false,
        "description": "Request for Error highlighting"
      },
      "ErrorHighlightResponse": {
        "required": [
          "errors",
          "sqlWithMarker"
        ],
        "type": "object",
        "properties": {
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ErrorHighlightItem"
            },
            "description": "The errors within the Sql"
          },
          "sqlWithMarker": {
            "minLength": 1,
            "type": "string",
            "description": "The SQL this is for, with characters indicating the error locations"
          }
        },
        "additionalProperties": false,
        "description": "Response for error highlighting"
      },
      "ExpressionWithAlias": {
        "required": [
          "expression"
        ],
        "type": "object",
        "properties": {
          "expression": {
            "minLength": 1,
            "type": "string",
            "description": "Expression (column name, constant, complex expression, etc.)"
          },
          "alias": {
            "type": "string",
            "description": "Column Alias for the expression",
            "nullable": true
          },
          "flags": {
            "$ref": "#/components/schemas/MappingFlags"
          }
        },
        "additionalProperties": false,
        "description": "Contract for an expression of data we \"have\" that we may \"want to map to a table-parameter's column\""
      },
      "FeedbackEventArgs": {
        "type": "object",
        "properties": {
          "when": {
            "type": "string",
            "format": "date-time"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid"
          },
          "executionId": {
            "type": "string",
            "format": "uuid"
          },
          "level": {
            "$ref": "#/components/schemas/FeedbackLevel"
          },
          "sender": {
            "type": "string",
            "nullable": true
          },
          "stateId": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "messageTemplate": {
            "type": "string",
            "nullable": true
          },
          "propertyValues": {
            "type": "array",
            "items": {},
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "FeedbackLevel": {
        "enum": [
          "None",
          "Progress",
          "Debug",
          "Information",
          "Warning",
          "Error",
          "ProgressAndError",
          "ProgressAndWarning",
          "ProgressAndInformation",
          "ProgressAndDebug",
          "ExecutionKeepAlive"
        ],
        "type": "string"
      },
      "FieldDesign": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the Field"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias if any (if none the Name is used)",
            "nullable": true
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "shouldSelect": {
            "type": "boolean",
            "description": "Should this be selected? False would imply it is only being filtered on.\r\nIgnored when Aggregations are present"
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterTermDesign"
            },
            "description": "Filter clauses to apply to this field (And'ed together)",
            "nullable": true
          },
          "aggregations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Aggregation"
            },
            "description": "Aggregations to apply (as opposed to simply selecting)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Treatment of a single field within a QueryDesign"
      },
      "FieldType": {
        "enum": [
          "Column",
          "Parameter"
        ],
        "type": "string"
      },
      "FileReaderBuilderDef": {
        "type": "object",
        "properties": {
          "autoDetect": {
            "$ref": "#/components/schemas/AutoDetectType"
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "Column information for the results",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "description": "What limit be added to the load query?  Less than or equal to zero means none",
            "format": "int32"
          },
          "source": {
            "$ref": "#/components/schemas/Source"
          },
          "availableSources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Source"
            },
            "description": "The source locations the user has access to.  The provider in essence.",
            "nullable": true
          },
          "variableName": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The name of the variable for the `use` statement",
            "nullable": true
          },
          "filePath": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The file (or folder) path",
            "nullable": true
          },
          "folderFilter": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The filter to apply to a folder (all matching files then being read) a RegExp",
            "nullable": true
          },
          "zipFilter": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The filter to apply to folder structures with zip archives (all matching files then being read) a RegExp",
            "nullable": true
          },
          "addFileName": {
            "type": "boolean",
            "description": "Should a file name column be added to the output?"
          },
          "csv": {
            "$ref": "#/components/schemas/OptionsCsv"
          },
          "excel": {
            "$ref": "#/components/schemas/OptionsExcel"
          },
          "sqLite": {
            "$ref": "#/components/schemas/OptionsSqLite"
          },
          "xml": {
            "$ref": "#/components/schemas/OptionsXml"
          },
          "parquet": {
            "$ref": "#/components/schemas/OptionsParquet"
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "FileReaderBuilderResponse": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "The generated SQL",
            "nullable": true
          },
          "error": {
            "type": "string",
            "description": "The error from running generated SQL Query, if any",
            "nullable": true
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "Column information for the results",
            "nullable": true
          },
          "data": {
            "description": "The resulting data from running the Query",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "FilterTermDesign": {
        "required": [
          "operator",
          "value"
        ],
        "type": "object",
        "properties": {
          "operator": {
            "$ref": "#/components/schemas/QueryDesignerBinaryOperator"
          },
          "value": {
            "maxLength": 2048,
            "minLength": 0,
            "type": "string",
            "description": "The value to compare against (always as a string, but will be formatted to the correct type)"
          }
        },
        "additionalProperties": false,
        "description": "A single filter clause"
      },
      "IdSelectorDefinition": {
        "required": [
          "actions",
          "identifier"
        ],
        "type": "object",
        "properties": {
          "identifier": {
            "minLength": 1,
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "actions": {
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActionId"
            }
          },
          "name": {
            "maxLength": 100,
            "minLength": 0,
            "type": "string",
            "nullable": true
          },
          "description": {
            "maxLength": 1024,
            "minLength": 0,
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "IntellisenseItem": {
        "required": [
          "caption",
          "value"
        ],
        "type": "object",
        "properties": {
          "caption": {
            "minLength": 1,
            "type": "string",
            "description": "The value to show the user in the popup"
          },
          "value": {
            "minLength": 1,
            "type": "string",
            "description": "The value to substitute in"
          },
          "meta": {
            "type": "string",
            "description": "The light-grey text shown to the right of the Caption in the popup",
            "nullable": true
          },
          "score": {
            "type": "integer",
            "description": "How important is this.  Bigger is more important.",
            "format": "int32"
          },
          "docHTML": {
            "type": "string",
            "description": "Popup further info (as in a whole documentation article!)",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/IntellisenseType"
          }
        },
        "additionalProperties": false,
        "description": "Representation of an item in an Intellisense popup"
      },
      "IntellisenseRequest": {
        "required": [
          "lines",
          "position"
        ],
        "type": "object",
        "properties": {
          "lines": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The lines of text the user currently has in the editor"
          },
          "position": {
            "$ref": "#/components/schemas/CursorPosition"
          }
        },
        "additionalProperties": false,
        "description": "Representation of a request for IntellisenseItems"
      },
      "IntellisenseResponse": {
        "required": [
          "autoCompleteList",
          "endReplacementPosition",
          "sqlWithMarker",
          "startReplacementPosition",
          "tryAgainSoonForMore"
        ],
        "type": "object",
        "properties": {
          "autoCompleteList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntellisenseItem"
            },
            "description": "The available items at this point"
          },
          "tryAgainSoonForMore": {
            "type": "boolean",
            "description": "Should the caller try again soon? (true means a cache is being built and this is a preliminary response!)"
          },
          "sqlWithMarker": {
            "minLength": 1,
            "type": "string",
            "description": "The SQL this is for with characters indicating the location the pop-up is for"
          },
          "startReplacementPosition": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "endReplacementPosition": {
            "$ref": "#/components/schemas/CursorPosition"
          }
        },
        "additionalProperties": false,
        "description": "Available intellisense response information"
      },
      "IntellisenseType": {
        "enum": [
          "Keyword",
          "Symbol",
          "Function",
          "Operator",
          "Table",
          "Column",
          "Parameter",
          "ScalarVariable"
        ],
        "type": "string"
      },
      "Link": {
        "required": [
          "href",
          "method",
          "relation"
        ],
        "type": "object",
        "properties": {
          "relation": {
            "type": "string"
          },
          "href": {
            "type": "string",
            "format": "uri"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "method": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "LuminesceBinaryType": {
        "enum": [
          "CommandLineTool",
          "LocalFileSystem_Providers",
          "Email_Providers",
          "Python_Providers",
          "AwsS3_Providers",
          "Azure_Providers",
          "SqlDb_Providers_Db2Linux",
          "SqlDb_Providers_MySql",
          "SqlDb_Providers_Oracle",
          "SqlDb_Providers_Oracle_Snowflake",
          "SqlDb_Providers_Postgresql",
          "SqlDb_Providers_Snowflake",
          "SqlDb_Providers_SqlServer",
          "SqlDb_Providers_SybaseAse",
          "SqlDb_Providers_SqLite",
          "SqlDb_Providers_DuckDb",
          "Jdbc_Driver",
          "PowerBi_Connector",
          "Odbc_Win64_Driver"
        ],
        "type": "string",
        "description": "Binaries that can be downloaded"
      },
      "LusidProblemDetails": {
        "required": [
          "code",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "minLength": 1,
            "type": "string"
          },
          "errorDetails": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "nullable": true
          },
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MappableField": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the field in need of mapping (The field name from within the Table Parameter itself)",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "description": {
            "type": "string",
            "description": "Description of the field (just for rendering to the user)",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Display Name of the field (just for rendering to the user)",
            "nullable": true
          },
          "sampleValues": {
            "type": "string",
            "description": "Example values for the field (just for rendering to the user)",
            "nullable": true
          },
          "allowedValues": {
            "type": "string",
            "description": "Any set of exactly allowed values for the field (perhaps just for rendering to the user, if nothing else)",
            "nullable": true
          },
          "mandatoryForActions": {
            "type": "string",
            "description": "Which `Actions` is this mandatory for? If any (and potentially when), perhaps just for rendering to the user, if nothing else",
            "nullable": true
          },
          "mapping": {
            "$ref": "#/components/schemas/ExpressionWithAlias"
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "MappingFlags": {
        "enum": [
          "None",
          "Exact",
          "Similar",
          "Additional"
        ],
        "type": "string"
      },
      "MultiQueryDefinitionType": {
        "enum": [
          "Instrument",
          "Expiry",
          "CorporateActions",
          "EdiInstrument",
          "EdiInstrumentWriter",
          "Testing",
          "MarketplaceClientLoadHistory",
          "InsightsMetricsEntitlement",
          "InstrumentDiscovery",
          "InstrumentUpsert"
        ],
        "type": "string"
      },
      "OptionsCsv": {
        "type": "object",
        "properties": {
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "columnNamesWanted": {
            "type": "string",
            "description": "Column (by Name) that should be returned (comma delimited list)",
            "nullable": true
          },
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "noHeader": {
            "type": "boolean",
            "description": "Set this if there is no header row"
          },
          "delimiter": {
            "type": "string",
            "description": "The delimiter between values (\\t for tab)",
            "nullable": true
          },
          "escape": {
            "type": "string",
            "description": "Character used to escape the 'Quote' character when within a value",
            "nullable": true
          },
          "quote": {
            "type": "string",
            "description": "Character used around any field containing the 'delimiter' or a line break.",
            "nullable": true
          },
          "valuesToMakeNull": {
            "type": "string",
            "description": "Regex of values to map to 'null' in the returned data.",
            "nullable": true
          },
          "skipPreHeader": {
            "type": "integer",
            "description": "Number of rows to ignore before the header row",
            "format": "int32"
          },
          "skipPostHeader": {
            "type": "integer",
            "description": "Number of rows to ignore after the header row",
            "format": "int32"
          },
          "skipInvalidRows": {
            "type": "boolean",
            "description": "Skip invalid data rows (totally invalid ones), \r\nThis also allows for potentially wrong data if it can be handled somewhat e.g. embedded quotes misused (and still returns such rows).\r\nIn either case a warning will show in the progress feedback."
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsExcel": {
        "type": "object",
        "properties": {
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "noHeader": {
            "type": "boolean",
            "description": "Set this if there is no header row"
          },
          "calculate": {
            "type": "boolean",
            "description": "Whether to attempt a calculation of the imported cell range prior to import"
          },
          "password": {
            "type": "string",
            "description": "If specified will be used as the password used for password protected workbooks",
            "nullable": true
          },
          "worksheet": {
            "type": "string",
            "description": "The worksheet containing the cell range to import (name or index, will default to first)",
            "nullable": true
          },
          "rangeOrTable": {
            "type": "string",
            "description": "The cell range to import as either a specified range or a table name",
            "nullable": true
          },
          "ignoreInvalidCells": {
            "type": "boolean",
            "description": "If specified cells which can not be successfully converted to the target type will be ignored"
          },
          "ignoreBlankRows": {
            "type": "boolean",
            "description": "If the entire rows has only blank cells it will be ignored will be ignored"
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsParquet": {
        "type": "object",
        "properties": {
          "columnNamesWanted": {
            "type": "string",
            "description": "Column (by Name) that should be returned (comma delimited list)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsSqLite": {
        "type": "object",
        "properties": {
          "table": {
            "type": "string",
            "description": "Table name to read.  If missing then an error will be raised if there is any number of tables other than one.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsXml": {
        "type": "object",
        "properties": {
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "valuesToMakeNull": {
            "type": "string",
            "description": "Regex of values to map to 'null' in the returned data.",
            "nullable": true
          },
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "nodePath": {
            "type": "string",
            "description": "XPath query that selects the nodes to map to rows",
            "nullable": true
          },
          "namespaces": {
            "type": "string",
            "description": "Selected prefix(es) and namespace(s):prefix1=namespace1-uri1,prefix2=namespace2-uri2,...prefixN=namespaceN-uriN",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OrderByDirection": {
        "enum": [
          "asc",
          "desc"
        ],
        "type": "string",
        "description": "Direction of Order By terms in the Order By clause"
      },
      "OrderByTermDesign": {
        "required": [
          "field"
        ],
        "type": "object",
        "properties": {
          "field": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the field to order by"
          },
          "direction": {
            "$ref": "#/components/schemas/OrderByDirection"
          }
        },
        "additionalProperties": false,
        "description": "A single clause within an Order BY"
      },
      "QueryDesign": {
        "required": [
          "fields",
          "tableName"
        ],
        "type": "object",
        "properties": {
          "tableName": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the table being designed"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias for the table in the generated SQL, if any",
            "nullable": true
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldDesign"
            },
            "description": "Fields to be selected, aggregated over and/or filtered on"
          },
          "orderBy": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OrderByTermDesign"
            },
            "description": "Order By clauses to apply",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "description": "Row limit to apply, if any",
            "format": "int32",
            "nullable": true
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Any warnings to show the user when converting from SQL to this representation",
            "nullable": true
          },
          "availableFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailableField"
            },
            "description": "Fields that are known to be available for design when parsing SQL",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of a \"designable Query\" suitable for formatting to SQL or being built from compliant SQL."
      },
      "QueryDesignerBinaryOperator": {
        "enum": [
          "Lt",
          "Lte",
          "Gt",
          "Gte",
          "Eq",
          "Neq",
          "Like",
          "Contains",
          "StartsWith",
          "EndsWith"
        ],
        "type": "string"
      },
      "ResourceListOfAccessControlledResource": {
        "required": [
          "values"
        ],
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResource"
            }
          },
          "href": {
            "type": "string",
            "format": "uri",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "nullable": true
          },
          "nextPage": {
            "type": "string",
            "nullable": true
          },
          "previousPage": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Source": {
        "type": "object",
        "properties": {
          "location": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The source location.  Start of a provider name, `Drive`, `LocalFs`, `AwsS3` etc.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/SourceType"
          }
        },
        "additionalProperties": false,
        "description": "Information leading to choosing the provider"
      },
      "SourceType": {
        "enum": [
          "Unknown",
          "Csv",
          "Excel",
          "SqLite",
          "Xml",
          "Parquet",
          "RawText"
        ],
        "type": "string",
        "description": "The file type of a source"
      },
      "TaskStatus": {
        "enum": [
          "Created",
          "WaitingForActivation",
          "WaitingToRun",
          "Running",
          "WaitingForChildrenToComplete",
          "RanToCompletion",
          "Canceled",
          "Faulted"
        ],
        "type": "string"
      },
      "ViewParameter": {
        "required": [
          "dataType",
          "name",
          "value"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the provider"
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "value": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Value of the provider"
          },
          "isTableDataMandatory": {
            "type": "boolean",
            "description": "Should this be selected? False would imply it is only being filtered on.\r\nIgnored when Aggregations are present"
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Description of the parameter",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Parameters of view"
      },
      "WriterDesign": {
        "required": [
          "sql"
        ],
        "type": "object",
        "properties": {
          "sql": {
            "minLength": 1,
            "type": "string",
            "description": "Original SQL that started this off"
          },
          "availableToMapFrom": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpressionWithAlias"
            },
            "description": "The data able to be mapped from as derived from the Sql",
            "nullable": true
          },
          "parameter": {
            "$ref": "#/components/schemas/AvailableParameter"
          },
          "availableParameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailableParameter"
            },
            "description": "All the parameter the user may wish to design",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of a \"designable Query for a writer\" suitable for formatting to SQL or being built from compliant SQL."
      }
    },
    "securitySchemes": {
      "oauth2": {
        "type": "oauth2",
        "description": "OAuth2 Implicit Grant",
        "flows": {
          "implicit": {
            "authorizationUrl": "https://lusid-fbn-ci.okta.com/oauth2/aus49h9b8rQPvouCH2p7/v1/authorize",
            "scopes": {}
          }
        }
      }
    }
  },
  "security": [
    {}
  ],
  "tags": [
    {
      "name": "Application Metadata",
      "description": "Metadata about the application"
    },
    {
      "name": "Binary Downloading",
      "description": "Allows for the downloading of Luminesce Binaries, given the required entitlements.\nThese are to allow various functionalities to be run outside of Finbourne cloud infrastructure.\nFor example to connection to internal databases, run providers on users' machines, or obtain the LuminesceCLI."
    },
    {
      "name": "Certificate Management",
      "description": "List, Mint, Renew and Revoke your Honeycomb / Luminesce TLS Certificates."
    },
    {
      "name": "Current Table/Field Catalog",
      "description": "Shows Table and Field level information on Providers that are currently running that you have access to."
    },
    {
      "name": "Historically Executed Queries",
      "description": "Shows queries executed at some point and details about them"
    },
    {
      "name": "Multi-Query Execution",
      "description": "This executes a series of internally defined LuminesceSql statements in the background"
    },
    {
      "name": "Sql Background Execution",
      "description": "This executes LuminesceSql and allows monitoring its completion"
    },
    {
      "name": "Sql Design",
      "description": "This has methods for Designing SQL (to support the Web GUI designer interfaces) for pretty-printing of sql, etc."
    },
    {
      "name": "Sql Execution",
      "description": "This executes LuminesceSql synchronously, allows for returning the resulting data in various formats."
    }
  ],
  "x-tagGroups": {
    "name": "API",
    "tags": [
      "Application Metadata",
      "Binary Downloading",
      "Certificate Management",
      "Current Table/Field Catalog",
      "Historically Executed Queries",
      "Multi-Query Execution",
      "Sql Background Execution",
      "Sql Design",
      "Sql Execution"
    ]
  }
}
