{
  "openapi": "3.0.1",
  "info": {
    "title": "FINBOURNE Luminesce Web API",
    "description": "FINBOURNE Technology",
    "termsOfService": "https://www.finbourne.com/legal/terms-conditions",
    "contact": {
      "name": "FINBOURNE Technology",
      "url": "https://www.finbourne.com",
      "email": "info@finbourne.com"
    },
    "version": "1.16.736",
    "x-logo": {
      "url": "https://www.lusid.com/app/assets/logo_white.png",
      "backgroundColor": "#415464"
    },
    "x-fbn-error-codes": {
      "233": {
        "title": "Query Parser Failure"
      },
      "850": {
        "title": "Required provider not visible; provider may not exist, be temporarily unavailable, or you may not have the necessary permissions"
      },
      "851": {
        "title": "Query reached a timeout period or was cancelled"
      },
      "852": {
        "title": "Query failed during execution"
      },
      "853": {
        "title": "Query failed during execution for an unexpected reason"
      },
      "854": {
        "title": "Query failed during execution for a reason known to be an internal error (e.g. a Lusid provider where a corresponding API would return a 500)"
      },
      "855": {
        "title": "Required column is not in the queried provider(s)"
      },
      "856": {
        "title": "One or more columns are ambiguously referenced in the query"
      },
      "857": {
        "title": "Query failed during execution of a provider (e.g. in a way that might be transient, like an upstream issue)"
      },
      "858": {
        "title": "Query failed during execution within the Query Engine's SQL processing"
      },
      "859": {
        "title": "A variable has been defined more than once"
      }
    },
    "x-fbn-description": "[Luminesce](https://support.lusid.com/knowledgebase/article/KA-01677/) is a data virtualization engine for LUSID and other applications. \nIt is proprietary technology designed and developed by FINBOURNE Technology Limited. \n[Understanding the Luminesce platform architecture.](https://support.lusid.com/knowledgebase/article/KA-01707/)\n\nLuminesce enables you to query multiple sources of business intelligence simultaneously in real-time—including investment management data stored in LUSID itself—and build a consolidated picture for analysis, optionally writing data back into LUSID. Alternatively, you can use Luminesce in a standalone capacity, without interacting with LUSID at all.\n\n### WebAPI\n\nAllows for running queries and a variety of other functions relating to Luminesce.\nFor example these REST APIs can execute queries, synchronously or better asynchronously, returning results in either Excel, CSV, SqLite, JSON among other formats.\n### Query Flow\n\nA much simplified view of the flow of a query request and service interrelationships.\n\n```mermaid\ngraph TD\nsubgraph SVC[\"Core Services\"]\n  S1[\"HcFS\"]\n  S2[\"Nameservice\"]\nend\n\nSVC -.- Providers\nSVC -.- QC\n\nsubgraph QC[\"Query Coordinator\"]\n  D -.->|These depend on nothing else | CP1\n  D -.->|Need Limits based on<br/> previous provider calls | CP2\n  CP1{ } -.->|\"Limiting data (as tables)\"| CP2{ }\n  CP1 -.-> P6[\"View.X.y.z\"]\nend\n\nsubgraph Clients\n  P6 -.-> D\n  A -.-> D(Query Engine and<br/>Dependency Tree Analyser)\n  C1[\"CLI\"] -.-> A[API]\n  C1[\"CLI\"] -.-> C2\n  C2[WebAPI] -.-> A\n  C4[Lumipy] -.-> C2\n  C5[JDBC] -.-> C2\n  C3[ODBC] -.-> A\n  C3[ODBC] -.-> C2\nend\n\nsubgraph Providers\n  PF[Factories ...]\n  CP1 -.-> P1[\"Drive.Csv\"]\n  CP1 -.-> P2[\"Quotes\"]\n  CP2 -.-> P3[\"Instruments\"]\n  CP2 -.-> P4[\"Portfolios\"]\n  CP2 -.-> PX\n  PX[...]\n  PX2[... ... ...]\nend\n\nsubgraph Legend\n  direction LR\n  X1[ ] -.->|\"HTTPS 443\"| Y1[ ]\n  X2[ ] -.->|\"AMQP 5671<br/>(or Hutch-Proxy 443->5671)\"| Y2[ ]\n  X4[ ] -.->|In process/code| Y4[ ]\nend\n\nlinkStyle 21 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 0 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 1 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 7 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 15 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 16 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 17 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 18 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\nlinkStyle 19 stroke:#ff6767, stroke-dasharray: 10 2, stroke-width:2px;\n\nlinkStyle 20 stroke:#26a3ff, stroke-dasharray: 5 2, stroke-width:2px;\nlinkStyle 9 stroke:#26a3ff, stroke-dasharray: 5 2, stroke-width:2px;\nlinkStyle 11 stroke:#26a3ff, stroke-dasharray: 5 2, stroke-width:2px;\nlinkStyle 12 stroke:#26a3ff, stroke-dasharray: 5 2, stroke-width:2px;\nlinkStyle 14 stroke:#26a3ff, stroke-dasharray: 5 2, stroke-width:2px;\n```\n\n"
  },
  "servers": [
    {
      "url": "https://www.lusid.com/honeycomb"
    }
  ],
  "paths": {
    "/api/Catalog": {
      "get": {
        "tags": [
          "Current Table/Field Catalog"
        ],
        "summary": "GetCatalog: Get a Flattened Table/Field Catalog",
        "description": "\nReturns the User's full version of the catalog (Providers, their fields and associated information)\nthat are currently running that you have access to (in Json format).\n\nThis is the entire catalog flattened, which is often quite large and always a bit repetitive.  \nThe internal results are cached for several minutes.\n\nConsider using `api/Catalog/providers` and `api/Catalog/fields` for a more granular and incremental loading flow.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetCatalog",
        "parameters": [
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Limit the catalog to only things in some way dealing with the passed in text string",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "useCache",
            "in": "query",
            "description": "Should the available cache be used? false is effectively to pick up a change in the catalog",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Catalog/fields": {
      "get": {
        "tags": [
          "Current Table/Field Catalog"
        ],
        "summary": "GetFields: List field and parameters for providers",
        "description": "\nReturns the User's full version of the catalog but only the field/parameter-level information \n(as well as the TableName they refer to, of course) for tables matching the `tableLike` (manually include wildcards if desired).\n\nThe internal results are cached for several minutes.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetFields",
        "parameters": [
          {
            "name": "tableLike",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "%"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Catalog/providers": {
      "get": {
        "tags": [
          "Current Table/Field Catalog"
        ],
        "summary": "GetProviders: List available providers",
        "description": "\nReturns the User's full version of the catalog but only the table/provider-level information they have access to.\n\nThe internal results are cached for several minutes.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetProviders",
        "parameters": [
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Limit the catalog to only things in some way dealing with the passed in text string",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "useCache",
            "in": "query",
            "description": "Should the available cache be used? false is effectively to pick up a change in the catalog",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Certificate/certificate": {
      "get": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] DownloadCertificate: Download domain or your personal certificates",
        "description": "\nDownloads your latest Domain or your User certificate's public or private key - if any.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - certificate is not available for some reason\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "DownloadCertificate",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "User or Domain level cert (Domain level requires additional entitlements)",
            "schema": {
              "$ref": "#/components/schemas/CertificateType"
            },
            "x-nullable": true
          },
          {
            "name": "fileType",
            "in": "query",
            "description": "Should the public key or private key be downloaded? (both must be in place to run providers)",
            "schema": {
              "$ref": "#/components/schemas/CertificateFileType"
            },
            "x-nullable": true
          },
          {
            "name": "mayAutoCreate",
            "in": "query",
            "description": "If no matching cert is available, should an attempt be made to Create/Renew it with default options?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Certificate/certificates": {
      "get": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] ListCertificates: List previously minted certificates",
        "description": "\nLists all the certificates previously minted to which you have access.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "ListCertificates",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CertificateState"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Certificate/manage": {
      "put": {
        "tags": [
          "Certificate Management"
        ],
        "summary": "[EXPERIMENTAL] ManageCertificate: Create / Renew / Revoke a certificate",
        "description": "\nManages a certificate.  This could be creating a new one, renewing an old one or revoking one explicitly.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something about the request cannot be processed\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "ManageCertificate",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "The Action to perform, e.g. Create / Renew / Revoke",
            "schema": {
              "$ref": "#/components/schemas/CertificateAction"
            },
            "x-nullable": true
          },
          {
            "name": "type",
            "in": "query",
            "description": "User or Domain level cert (Domain level requires additional entitlements)",
            "schema": {
              "$ref": "#/components/schemas/CertificateType"
            },
            "x-nullable": true
          },
          {
            "name": "version",
            "in": "query",
            "description": "Version number of the cert, the request will fail to validate if incorrect",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 1
            },
            "x-nullable": true
          },
          {
            "name": "validityStart",
            "in": "query",
            "description": "When should the cert first be valid (defaults to the current time in UTC)",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "validityEnd",
            "in": "query",
            "description": "When should the cert no longer be valid (defaults to 13 months from now)",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "dryRun",
            "in": "query",
            "description": "True will just validate the request, but perform no changes to any system",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/CertificateState"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Download/download": {
      "get": {
        "tags": [
          "Binary Downloading"
        ],
        "summary": "[EXPERIMENTAL] DownloadBinary: Download a Luminesce Binary you may run on-site",
        "description": "\nDownloads the latest version (or specific if needs be) of the specified Luminesce Binary, given the required entitlements.\n\n> This endpoint is an alternative to time-consuming manual distribution via Drive or Email.\n> it relies on an underlying datastore that is not quite as \"Highly Available\" to the degree \n> that FINBOURNE services generally are.  \n> Thus it is not subject to the same SLAs as other API endpoints are.\n> *If you perceive an outage, please try again later.*\n\nOnce a file has been downloaded the following steps can be used to install it (for the dotnet tools at least):\n\n1. Open a terminal and cd to the directory you downloaded it to\n2. Install / extract files from that package via:\n```\ndotnet tool install NameOfFileWithoutVersionNumberOrExtension -g --add-source \".\"\n```\ne.g.\n```\ndotnet tool install Finbourne.Luminesce.DbProviders.Oracle_Snowflake -g --add-source \".\"\n```\n3. Execute them (see documentation for specific binary)...\n\nThe installed binaries can then be found in\n- Windows - `%USERPROFILE%\\.dotnet\\tools\\.store\\`\n- Linux/macOS - `$HOME/.dotnet/tools/.store/`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - binary file is not available for some reason (e.g. permissions or invalid version)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "DownloadBinary",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Type of binary to download (each requires separate licenses and entitlements)",
            "schema": {
              "$ref": "#/components/schemas/LuminesceBinaryType"
            },
            "x-nullable": true
          },
          {
            "name": "version",
            "in": "query",
            "description": "An explicit version of the binary.  Leave blank to get the latest version (recommended)",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The .nupkg or .msi file of the requested binary",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Download/versions": {
      "get": {
        "tags": [
          "Binary Downloading"
        ],
        "summary": "[EXPERIMENTAL] GetBinaryVersions: List available versions of binaries",
        "description": "\nGets all available versions of a given binary type (from newest to oldest)\nThis does not mean you are entitled to download them.",
        "operationId": "GetBinaryVersions",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "Type of binary to fetch available versions of",
            "schema": {
              "$ref": "#/components/schemas/LuminesceBinaryType"
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/History": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetHistory: Start a background history search",
        "description": "\nStarts to load the historical query logs for a certain time range, search criteria, etc.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetHistory",
        "parameters": [
          {
            "name": "startAt",
            "in": "query",
            "description": "Date time to start the search from.  Will default to Now - 1 Day",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "Date time to end the search at.  Defaults to now.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Some test that must be in at least one field returned.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "showAll",
            "in": "query",
            "description": "For users with extra permissions, they may optionally see other users' queries.",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "mayUseNativeStore",
            "in": "query",
            "description": "Should a native data store (e.g. Athena or Fabric) be used over Elastic Search if available?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetProgressOfHistory: View progress of a history search",
        "description": "View progress information (up until this point) of previously started History query\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "CancelHistory: Cancel / Clear data from a history search",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/histogram": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultHistogram: Make a histogram of results of a history search",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/json": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultJson: Fetch JSON results from a query history search",
        "description": "Fetch the data in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/metadata/access/resources": {
      "get": {
        "tags": [
          "Application Metadata"
        ],
        "summary": "GetServicesAsAccessControlledResources: Get resources available for access control",
        "description": "\nGet the comprehensive set of resources that are available for access control.\n\nThe following LuminesceSql is executed to return this information, \nwhich is then packaged up as AccessControlledResource:\n\n```sql\nselect\n    Name,\n    min(coalesce(Description, Name) || ' (' || Type || ')') as Description\nfrom\n    Sys.Registration\nwhere\n    Type in ('DirectProvider', 'DataProvider')\n    and\n    ShowAll = true\ngroup by 1\norder by 1\n   \n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetServicesAsAccessControlledResources",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground": {
      "put": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "StartQueries: Run a given set of Sql queries in the background",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis\n- view progress information (up until this point), for all results in one go\n- cancel the queries (if still running) / clear the data (if already returned)\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "StartQueries",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "An enum value defining the set of statements being executed",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MultiQueryDefinitionType"
            },
            "example": "Instrument"
          },
          {
            "name": "asAt",
            "in": "query",
            "description": "The AsAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "effectiveAt",
            "in": "query",
            "description": "The EffectiveAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "limit1",
            "in": "query",
            "description": "A limit that is applied to first-level queries (e.g. Instruments themselves)",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-nullable": true
          },
          {
            "name": "limit2",
            "in": "query",
            "description": "A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found)",
            "schema": {
              "type": "integer",
              "format": "int32"
            },
            "x-nullable": true
          },
          {
            "name": "input1",
            "in": "query",
            "description": "A value available to queries, these vary by 'type' and are only used by some types at all.\r\ne.g. a start-date of some sort",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "input2",
            "in": "query",
            "description": "A second value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "input3",
            "in": "query",
            "description": "A third value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 1200s (20m)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 1200,
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 7200,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "A \"search\" value (e.g. 'Apple' on an instrument search, a `Finbourne.Filtering` expression of Insights, etc.)\r\nIn the cases where \"Nothing\" is valid for a `Finbourne.Filtering` expression, pass `True`.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "Apple"
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground/{executionId}": {
      "get": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "GetProgressOfMultiQuery: View progress of the entire query-set load",
        "description": "View progress information (up until this point) for the entire query-set\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "CancelMultiQuery: Cancel / Clear a previously started query-set",
        "description": "Cancel the query-set (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryCsv: Execute Sql from the body returning CSV",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryCsv",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryCsv: Execute Sql from the url returning CSV",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryCsv",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryExcel: Execute Sql from the body making an Excel file",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryExcel",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryExcel: Execute Sql from the url returning an Excel file",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryExcel",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/extractscalarparameters": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToExtractScalarParameters: Extract scalar parameter information from SQL",
        "description": "Extracts information about all the scalar parameters defined in the given SQL statement\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutSqlToExtractScalarParameters",
        "requestBody": {
          "description": "SQL query to generate the design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select abc, :p1:'this' as c1 from xxx where abc = :abcP:123 or xyz in (:p2:, 'zzz')"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScalarParameter"
                  }
                },
                "example": [
                  {
                    "name": "p1",
                    "type": "Text",
                    "value": "this"
                  },
                  {
                    "name": "abcP",
                    "type": "Decimal",
                    "value": "123"
                  },
                  {
                    "name": "p2",
                    "type": "Text"
                  }
                ]
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScalarParameter"
                  }
                },
                "example": [
                  {
                    "name": "p1",
                    "type": "Text",
                    "value": "this"
                  },
                  {
                    "name": "abcP",
                    "type": "Decimal",
                    "value": "123"
                  },
                  {
                    "name": "p2",
                    "type": "Text"
                  }
                ]
              },
              "text/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScalarParameter"
                  }
                },
                "example": [
                  {
                    "name": "p1",
                    "type": "Text",
                    "value": "this"
                  },
                  {
                    "name": "abcP",
                    "type": "Decimal",
                    "value": "123"
                  },
                  {
                    "name": "p2",
                    "type": "Text"
                  }
                ]
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromcasestatementdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutCaseStatementDesignToSql: Convert a case statement design object to SQL",
        "description": "Generates a SQL case statement query from a structured CaseStatementDesign object\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutCaseStatementDesignToSql",
        "requestBody": {
          "description": "CaseStatementDesign object to try and create a SQL query from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/CaseStatementDesign"
              },
              "example": {
                "selectedField": "currency",
                "caseStatementItems": [
                  {
                    "filter": "Eq",
                    "source": "USD",
                    "target": "US",
                    "isTargetNonLiteral": false
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CaseStatementDesign"
              },
              "example": {
                "selectedField": "currency",
                "caseStatementItems": [
                  {
                    "filter": "Eq",
                    "source": "USD",
                    "target": "US",
                    "isTargetNonLiteral": false
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/CaseStatementDesign"
              },
              "example": {
                "selectedField": "currency",
                "caseStatementItems": [
                  {
                    "filter": "Eq",
                    "source": "USD",
                    "target": "US",
                    "isTargetNonLiteral": false
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/CaseStatementDesign"
              },
              "example": {
                "selectedField": "currency",
                "caseStatementItems": [
                  {
                    "filter": "Eq",
                    "source": "USD",
                    "target": "US",
                    "isTargetNonLiteral": false
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutQueryDesignToSql: Make SQL from a structured query design",
        "description": "Generates SQL from a QueryDesign object\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutQueryDesignToSql",
        "requestBody": {
          "description": "Structured Query design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/QueryDesign"
              },
              "example": {
                "tableName": "Sys.Field",
                "fields": [
                  {
                    "name": "TableName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [
                      {
                        "operator": "Eq",
                        "value": "Sys.Registration"
                      }
                    ],
                    "aggregations": []
                  },
                  {
                    "name": "FieldName",
                    "dataType": "Text",
                    "shouldSelect": true,
                    "filters": [],
                    "aggregations": [
                      {
                        "type": "count_distinct",
                        "alias": "NumberOfFields"
                      }
                    ]
                  }
                ],
                "orderBy": [
                  {
                    "field": "DataType",
                    "direction": "asc"
                  }
                ],
                "limit": 42,
                "warnings": [],
                "availableFields": []
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromfilereaddesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutFileReadDesignToSql: Make file read SQL from a design object",
        "description": "Generates SQL from a FileReaderBuilderDef object\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutFileReadDesignToSql",
        "parameters": [
          {
            "name": "executeQuery",
            "in": "query",
            "description": "Should the generated query be executed to build preview data or determine errors.>",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "Structured file read design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/FileReaderBuilderDef"
              },
              "example": {
                "limit": 0,
                "source": {
                  "location": "Drive",
                  "type": "Csv"
                },
                "filePath": "/some/folder",
                "folderFilter": ".*\\.csv",
                "addFileName": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/frominlinedpropertiesdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutInlinedPropertiesDesignToSql: Make inlined properties SQL from a design object",
        "description": "Generates inlined properties SQL from a structured design\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutInlinedPropertiesDesignToSql",
        "requestBody": {
          "description": "Inlined properties Designer specification to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/InlinedPropertyDesign"
              },
              "example": {
                "providerName": "Lusid.portfolio",
                "inlinedPropertyItems": [
                  {
                    "key": "fieldKey",
                    "name": "fieldName",
                    "isMain": true,
                    "description": "some description"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InlinedPropertyDesign"
              },
              "example": {
                "providerName": "Lusid.portfolio",
                "inlinedPropertyItems": [
                  {
                    "key": "fieldKey",
                    "name": "fieldName",
                    "isMain": true,
                    "description": "some description"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/InlinedPropertyDesign"
              },
              "example": {
                "providerName": "Lusid.portfolio",
                "inlinedPropertyItems": [
                  {
                    "key": "fieldKey",
                    "name": "fieldName",
                    "isMain": true,
                    "description": "some description"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/InlinedPropertyDesign"
              },
              "example": {
                "providerName": "Lusid.portfolio",
                "inlinedPropertyItems": [
                  {
                    "key": "fieldKey",
                    "name": "fieldName",
                    "isMain": true,
                    "description": "some description"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromviewdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutViewDesignToSql: Make view creation sql from a view-design",
        "description": "Converts a ConvertToView specification into SQL that creates a view\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutViewDesignToSql",
        "requestBody": {
          "description": "Structured Query design object to generate SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/ConvertToViewData"
              },
              "example": {
                "query": "select * from Lusid.Instrument.bond",
                "name": "Views.MyView",
                "description": "This is a tooltip for the view as a whole",
                "documentationLink": "https://mydocumentationlink.com",
                "viewParameters": [
                  {
                    "name": "MyTextParam",
                    "dataType": "Text",
                    "value": "Portfolio",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EffectiveAt",
                    "dataType": "Date",
                    "value": "2023-05-03",
                    "isTableDataMandatory": false,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "IsActive",
                    "dataType": "Boolean",
                    "value": "true",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  },
                  {
                    "name": "EndUserTable",
                    "dataType": "Table",
                    "value": "@end_user_table",
                    "isTableDataMandatory": true,
                    "description": "This is a parameter tooltip"
                  }
                ],
                "otherParameters": {}
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/fromwriterdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutWriterDesignToSql: Make writer SQL from a writer-design object",
        "description": "Generates writer SQL from a valid WriterDesign structure\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutWriterDesignToSql",
        "requestBody": {
          "description": "Structured Writer Design design object to generate Writer SQL from",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/WriterDesign"
              },
              "example": {
                "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                "availableToMapFrom": [
                  {
                    "expression": "SomeScope",
                    "alias": "Scope",
                    "flags": "None"
                  }
                ],
                "parameter": {
                  "providerName": "Lusid.Instrument.Bond",
                  "parameterName": "ToWrite",
                  "fields": [
                    {
                      "name": "Scope",
                      "type": "Text",
                      "description": "Scope of the instrument",
                      "mapping": {
                        "expression": "SomeScope",
                        "alias": "Scope",
                        "flags": "None"
                      }
                    },
                    {
                      "name": "DisplayName",
                      "type": "Text"
                    }
                  ]
                },
                "availableParameters": [
                  {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  {
                    "providerName": "Email.Send",
                    "parameterName": "ToSend",
                    "fields": [
                      {
                        "name": "Subject",
                        "type": "Text"
                      },
                      {
                        "name": "Body",
                        "type": "Text"
                      }
                    ]
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/intellisense": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "PutIntellisense: Make intellisense prompts given an SQL snip-it",
        "description": "Generate a set of possible intellisense prompts given a SQL snip-it (in need not yet be valid SQL) and cursor location\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutIntellisense",
        "requestBody": {
          "description": "SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/IntellisenseRequest"
              },
              "example": {
                "lines": [
                  "select *",
                  "from somewhere"
                ],
                "position": {
                  "row": 0,
                  "column": 4
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntellisenseResponse"
                },
                "example": {
                  "autoCompleteList": [
                    {
                      "caption": "SELECT",
                      "value": "SELECT",
                      "meta": "select some data",
                      "score": 100,
                      "docHTML": "<p>Select some data!</p>",
                      "type": "Keyword"
                    },
                    {
                      "caption": "VALUES",
                      "value": "VALUES",
                      "meta": "some hard-coded data",
                      "score": 100,
                      "docHTML": "<p>values give you data</p>",
                      "type": "Keyword"
                    }
                  ],
                  "tryAgainSoonForMore": false,
                  "sqlWithMarker": "▷select◁︎ * from somewhere"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/intellisenseError": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "PutIntellisenseError: Get error ranges from SQL",
        "description": "Generate a set of error ranges, if any, in the given SQL (expressed as Lines)\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutIntellisenseError",
        "requestBody": {
          "description": "SQL (by line) to syntax check and return error ranges from within, if any.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/ErrorHighlightRequest"
              },
              "example": {
                "lines": [
                  "select mx(x) x from y"
                ],
                "ensureSomeTextIsSelected": false
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorHighlightResponse"
                },
                "example": {
                  "errors": [
                    {
                      "start": {
                        "row": 0,
                        "column": 9
                      },
                      "stop": {
                        "row": 0,
                        "column": 10
                      },
                      "length": 1,
                      "message": "extraneous input '(' expecting {<EOF>, '@', '@@', ';', K_PRAGMA, K_SELECT, K_TYPES, K_VALUES, UNEXPECTED_CHAR}"
                    }
                  ],
                  "sqlWithMarker": "select mx▷(◁︎x) x from y"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/json": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryJson: Execute Sql from the body returning JSON",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryJson",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/json/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryJson: Execute Sql from the url returning JSON",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryJson",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/parquet": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryParquet: Execute Sql from the body making a Parquet file",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryParquet",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/parquet/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryParquet: Execute Sql from the url returning a Parquet file",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryParquet",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryPipe: Execute Sql from the body making pipe-delimited",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryPipe",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryPipe: Execute Sql from the url returning pipe-delimited",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryPipe",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pretty": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "PutQueryToFormat: Format SQL into a more readable form",
        "description": "\nThis formats SQL (given a set of options as to how to do so), a.k.a. Pretty-Print the SQL.\nIt takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly)\nand returns the reformatted version.\ne.g.\n```sql\nselect x,y,z from a inner join b on a.x=b.x where x>y or y!=z\n```\nbecomes\n```sql\nselect x, y, z\nfrom a\ninner join b\n   on a.x = b.x\nwhere x > y\n   or y != z\n```\n",
        "operationId": "PutQueryToFormat",
        "parameters": [
          {
            "name": "trailingCommas",
            "in": "query",
            "description": "Should commas be after an expression (as opposed to before)",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "uppercaseKeywords",
            "in": "query",
            "description": "Should key words be capitalized",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "breakJoinOnSections",
            "in": "query",
            "description": "Should clauses on joins be given line breaks?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "spaceAfterExpandedComma",
            "in": "query",
            "description": "Should comma-lists have spaces after the commas?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "keywordStandardization",
            "in": "query",
            "description": "Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCommaLists",
            "in": "query",
            "description": "Should comma-lists (e.g. select a,b,c) have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandInLists",
            "in": "query",
            "description": "Should IN-lists have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandBooleanExpressions",
            "in": "query",
            "description": "Should boolean expressions have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandBetweenConditions",
            "in": "query",
            "description": "Should between conditions have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCaseStatements",
            "in": "query",
            "description": "Should case-statements have line breaks added?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "maxLineWidth",
            "in": "query",
            "description": "Maximum number of characters to allow on one line (if possible)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 120
            },
            "x-nullable": true
          },
          {
            "name": "spaceBeforeTrailingSingleLineComments",
            "in": "query",
            "description": "Should the be a space before trailing single line comments?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "multilineCommentExtraLineBreak",
            "in": "query",
            "description": "Should an additional line break be added after multi-line comments?",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/providertemplateforexport": {
      "get": {
        "tags": [
          "Sql Design"
        ],
        "summary": "GetProviderTemplateForExport: Makes a fields template for file importing via a writer",
        "description": "Generates a template file for all the writable fields for a given provider returned in CSV or Excel (xlsx) format (as a file to be downloaded)",
        "operationId": "GetProviderTemplateForExport",
        "parameters": [
          {
            "name": "provider",
            "in": "query",
            "description": "Name of the provider for which this template is for",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "contentType",
            "in": "query",
            "description": "File content type for the Template. csv or excel",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQuerySqlite: Execute Sql from the body returning SqLite DB",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQuerySqlite",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQuerySqlite: Execute Sql from the url returning SqLite DB",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQuerySqlite",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/tocasestatementdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutCaseStatementDesignSqlToDesign: Convert SQL to a case statement design object",
        "description": "Converts a SQL query to a CaseStatementDesign object\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutCaseStatementDesignSqlToDesign",
        "requestBody": {
          "description": "SQL to attempt to create an case statement Design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "CASE \n WHEN [currency] = 'US' THEN 'USD' \n WHEN [currency] = 'Gb' THEN 'GBP' \n ELSE [currency] \n END"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/CaseStatementDesign"
                },
                "example": {
                  "selectedField": "currency",
                  "caseStatementItems": [
                    {
                      "filter": "Eq",
                      "source": "USD",
                      "target": "US",
                      "isTargetNonLiteral": false
                    }
                  ]
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CaseStatementDesign"
                },
                "example": {
                  "selectedField": "currency",
                  "caseStatementItems": [
                    {
                      "filter": "Eq",
                      "source": "USD",
                      "target": "US",
                      "isTargetNonLiteral": false
                    }
                  ]
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/CaseStatementDesign"
                },
                "example": {
                  "selectedField": "currency",
                  "caseStatementItems": [
                    {
                      "filter": "Eq",
                      "source": "USD",
                      "target": "US",
                      "isTargetNonLiteral": false
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/todesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToQueryDesign: Make a SQL-design object from SQL if possible",
        "description": "Generates a QueryDesign object from simple SQL if possible\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutSqlToQueryDesign",
        "parameters": [
          {
            "name": "validateWithMetadata",
            "in": "query",
            "description": "Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "SELECT\n    [TableName],\n    Count(distinct [FieldName]) as [NumberOfFields]\nFROM\n    [Sys.Field]\nWHERE\n    ([TableName] = 'Sys.Registration')\nGROUP BY\n    [TableName]\nORDER BY\n    [DataType]\nLIMIT 42"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryDesign"
                },
                "example": {
                  "tableName": "Sys.Field",
                  "fields": [
                    {
                      "name": "TableName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [
                        {
                          "operator": "Eq",
                          "value": "Sys.Registration"
                        }
                      ],
                      "aggregations": []
                    },
                    {
                      "name": "FieldName",
                      "dataType": "Text",
                      "shouldSelect": true,
                      "filters": [],
                      "aggregations": [
                        {
                          "type": "count_distinct",
                          "alias": "NumberOfFields"
                        }
                      ]
                    }
                  ],
                  "orderBy": [
                    {
                      "field": "DataType",
                      "direction": "asc"
                    }
                  ],
                  "limit": 42,
                  "warnings": [],
                  "availableFields": []
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/tofilereaddesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToFileReadDesign: Make a design object from file-read SQL",
        "description": "Generates a SQL-file-read-design object from SQL string, if possible.\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutSqlToFileReadDesign",
        "parameters": [
          {
            "name": "determineAvailableSources",
            "in": "query",
            "description": "Should the available sources be determined from `Sys.Registration`",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the file read design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "@x = \nuse Drive.Csv\n  --file=/some/folder/somefile.csv\nenduse;\n\nselect * from @x;"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileReaderBuilderDef"
                },
                "example": {
                  "limit": 0,
                  "source": {
                    "location": "Drive",
                    "type": "Csv"
                  },
                  "filePath": "/some/folder",
                  "folderFilter": ".*\\.csv",
                  "addFileName": true
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/toinlinedpropertiesdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutInlinedPropertiesDesignSqlToDesign: Make an inlined properties design from SQL",
        "description": "Generates a SQL-inlined-properties-design object from SQL string, if possible.\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutInlinedPropertiesDesignSqlToDesign",
        "requestBody": {
          "description": "SQL query to attempt to generate the inlined properties design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "@keysToCatalog = values('Portfolio/3897-78d4-e91c-26/location', 'PortfolioLocation', false, '');\n @config = select column1 as [Key], column2 as Name, column3 as IsMain, column4 as Description from @keysToCatalog; \n select * from Sys.Admin.Lusid.Provider.Configure where Provider = 'Lusid.Portfolio' and Configuration = @config;"
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/InlinedPropertyDesign"
                },
                "example": {
                  "providerName": "Lusid.portfolio",
                  "inlinedPropertyItems": [
                    {
                      "key": "fieldKey",
                      "name": "fieldName",
                      "isMain": true,
                      "description": "some description"
                    }
                  ]
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InlinedPropertyDesign"
                },
                "example": {
                  "providerName": "Lusid.portfolio",
                  "inlinedPropertyItems": [
                    {
                      "key": "fieldKey",
                      "name": "fieldName",
                      "isMain": true,
                      "description": "some description"
                    }
                  ]
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/InlinedPropertyDesign"
                },
                "example": {
                  "providerName": "Lusid.portfolio",
                  "inlinedPropertyItems": [
                    {
                      "key": "fieldKey",
                      "name": "fieldName",
                      "isMain": true,
                      "description": "some description"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/toviewdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToViewDesign: Make a view-design from view creation SQL",
        "description": "Converts SQL which creates a view into a structured ConvertToViewData object\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutSqlToViewDesign",
        "requestBody": {
          "description": "SQL Query to generate the ConvertToViewData object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "@x = \nuse Sys.Admin.SetupView\n  --provider=YourView\n----\nselect * from Lusid.Instrument\nenduse;\n\nselect * from @x;"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConvertToViewData"
                },
                "example": {
                  "query": "select * from Lusid.Instrument.bond",
                  "name": "Views.MyView",
                  "description": "This is a tooltip for the view as a whole",
                  "documentationLink": "https://mydocumentationlink.com",
                  "viewParameters": [
                    {
                      "name": "MyTextParam",
                      "dataType": "Text",
                      "value": "Portfolio",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EffectiveAt",
                      "dataType": "Date",
                      "value": "2023-05-03",
                      "isTableDataMandatory": false,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "IsActive",
                      "dataType": "Boolean",
                      "value": "true",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    },
                    {
                      "name": "EndUserTable",
                      "dataType": "Table",
                      "value": "@end_user_table",
                      "isTableDataMandatory": true,
                      "description": "This is a parameter tooltip"
                    }
                  ],
                  "otherParameters": {}
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/towriterdesign": {
      "put": {
        "tags": [
          "Sql Design"
        ],
        "summary": "[EXPERIMENTAL] PutSqlToWriterDesign: Make a SQL-writer-design object from SQL",
        "description": "Generates a SQL-writer-design object (WriterDesign) from a SQL query, if possible\n\n> This method is generally only intended for IDE generation purposes. \n> It is largely internal to the Finbourne web user interfaces and subject to change without notice.\n",
        "operationId": "PutSqlToWriterDesign",
        "parameters": [
          {
            "name": "mergeAdditionalMappingFields",
            "in": "query",
            "description": "Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "SQL query to generate the writer design object from",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "Select abc from xyz"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/WriterDesign"
                },
                "example": {
                  "sql": "\n@x = select SomeScope as Scope from Somewhere;\nselect * from Lusid.Instrument.Bond where ToWriter = @x",
                  "availableToMapFrom": [
                    {
                      "expression": "SomeScope",
                      "alias": "Scope",
                      "flags": "None"
                    }
                  ],
                  "parameter": {
                    "providerName": "Lusid.Instrument.Bond",
                    "parameterName": "ToWrite",
                    "fields": [
                      {
                        "name": "Scope",
                        "type": "Text",
                        "description": "Scope of the instrument",
                        "mapping": {
                          "expression": "SomeScope",
                          "alias": "Scope",
                          "flags": "None"
                        }
                      },
                      {
                        "name": "DisplayName",
                        "type": "Text"
                      }
                    ]
                  },
                  "availableParameters": [
                    {
                      "providerName": "Lusid.Instrument.Bond",
                      "parameterName": "ToWrite",
                      "fields": [
                        {
                          "name": "Scope",
                          "type": "Text",
                          "description": "Scope of the instrument",
                          "mapping": {
                            "expression": "SomeScope",
                            "alias": "Scope",
                            "flags": "None"
                          }
                        },
                        {
                          "name": "DisplayName",
                          "type": "Text"
                        }
                      ]
                    },
                    {
                      "providerName": "Email.Send",
                      "parameterName": "ToSend",
                      "fields": [
                        {
                          "name": "Subject",
                          "type": "Text"
                        },
                        {
                          "name": "Body",
                          "type": "Text"
                        }
                      ]
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Experimental"
      }
    },
    "/api/Sql/xml": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryXml: Execute Sql from the body returning XML",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer and line break delimited Sql, whic will be returned in the format of the method name.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "PutByQueryXml",
        "parameters": [
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select * from sys.field"
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/xml/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryXml: Execute Sql from the url returning XML",
        "description": "\nReturns data from a simple single-line query execution which is specified on the url.\ne.g. `select ^ from Sys.Field order by 1, 2`, returned in the format of the method name.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "GetByQueryXml",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "select ^ from Sys.Field order by 1, 2"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string"
            },
            "example": "Get tables/fields"
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 120,
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground": {
      "put": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "StartQuery: Start to Execute Sql in the background",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\n- view progress information (up until this point)\n- cancel the query (if still running) / clear the data (if already returned)\n\nThis can still error on things like an outright syntax error, but more runtime errors (e.g. from providers) will not\ncause this to error (that will happen when attempting to fetch data)\n\nHere is an example that intentionally takes one minute to run:\n\n```sql\nselect Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120\n```\n\nThis is the only place in the Luminesce WebAPI where the following is supported.\nThis will allow for the same user running a character-identical query not kick off a new query but simply be returned a reference \nto the already running one for up to `N` seconds (where `N` should be `<=` `keepForSeconds`).\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n- 403 Forbidden\n",
        "operationId": "StartQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "query",
            "description": "An explicit ExecutionId to use.  This must be blank OR assigned to a valid GUID-as-a-string.\r\nIt might be ignored / replaced, for example if using the query cache and a cached query is found.",
            "schema": {
              "type": "string"
            },
            "example": "686a0b70-0e97-4187-a2ab-509cf6d1091b"
          },
          {
            "name": "scalarParameters",
            "in": "query",
            "description": "Json encoded dictionary of key-value pairs for scalar parameter values to use in the sql execution.",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "example": {
              "someParameter": 12,
              "someOtherParameter": "someValue"
            },
            "x-nullable": true
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "A name for this query.  This goes into logs and is available in `Sys.Logs.HcQueryStart`.",
            "schema": {
              "type": "string"
            },
            "example": "Intentionally slow test query"
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 7200 (2h)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 1200,
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "example": 7200,
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "The LuminesceSql query to kick off.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              },
              "example": "select Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120"
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "GetProgressOf: View query progress up to this point",
        "description": "View progress information (up until this point and starting from the last point requested)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOf",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "buildFromLogs",
            "in": "query",
            "description": "Should the response state be build from query logs if missing from the shared-db-state?\r\nFalse will mean `404 Not Found` in cases where it was a real query but has passed its `keepForSeconds`\r\nsince the query completed (as well as 'this was not a query at all' of course)",
            "schema": {
              "type": "boolean",
              "default": true
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "CancelQuery: Cancel / Clear data from a previously run query",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/csv": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultCsv: Fetch the result of a query as CSV",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultCsv",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "delimiter",
            "in": "query",
            "description": "Delimiter string to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "escape",
            "in": "query",
            "description": "Escape character to override the default",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/excel": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultExcel: Fetch the result of a query as an Excel file",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultExcel",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/histogram": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultHistogram: Construct a histogram of the result of a query",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "timestampFieldName",
            "in": "query",
            "description": "Name of the timestamp field used in building the histogram",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startAt",
            "in": "query",
            "description": "Start point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "End point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "format": "date-time"
            },
            "x-nullable": true
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "format": "date-span"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/json": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJson: Fetch the result of a query as a JSON string",
        "description": "\n*Please move to '/jsonProper' instead.  This may be marked as Deprecated in the future.*\n\nFetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/jsonProper": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJsonProper: Fetch the result of a query as JSON",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJsonProper",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/parquet": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultParquet: Fetch the result of a query as Parquet",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultParquet",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/pipe": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultPipe: Fetch the result of a query as pipe-delimited",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultPipe",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/sqlite": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultSqlite: Fetch the result of a query as SqLite",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultSqlite",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/xml": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultXml: Fetch the result of a query as XML",
        "description": "Fetch the data in the format of the method's name (if available, or if not simply being informed it is not yet ready).\n\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultXml",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "maxLength": 16384,
              "minLength": 1,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "maxLength": 16384,
              "minLength": 0,
              "pattern": "^[\\s\\S]*$",
              "type": "string"
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "loadWaitMilliseconds",
            "in": "query",
            "description": "Optional period to wait for results deserialization if in progress when this method is called.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/fakeNodeReclaim": {
      "get": {
        "tags": [
          "Health checking endpoint"
        ],
        "summary": "[INTERNAL] FakeNodeReclaim: Helps testing of AWS node reclaim behaviour",
        "description": "\nAn internal Method used to mark the next SIGTERM as though an Aws Node reclaim were about to take place.\nSimulates having received an AWS node reclaim warning, or similar.",
        "operationId": "FakeNodeReclaim",
        "parameters": [
          {
            "name": "secondsUntilReclaim",
            "in": "query",
            "description": "the number of seconds from which to assume node termination",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 119
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ActionResult"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionResult"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ActionResult"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Internal"
      }
    }
  },
  "components": {
    "schemas": {
      "AccessControlledAction": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "action": {
            "$ref": "#/components/schemas/ActionId"
          },
          "limitedSet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdSelectorDefinition"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResource": {
        "type": "object",
        "properties": {
          "application": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledAction"
            },
            "nullable": true
          },
          "identifierParts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResourceIdentifierPartSchemaAttribute"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResourceIdentifierPartSchemaAttribute": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "required": {
            "type": "boolean"
          },
          "valuesPath": {
            "type": "string",
            "nullable": true
          },
          "typeId": {
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ActionId": {
        "required": [
          "activity",
          "entity",
          "scope"
        ],
        "type": "object",
        "properties": {
          "scope": {
            "maxLength": 100,
            "minLength": 3,
            "type": "string"
          },
          "activity": {
            "maxLength": 25,
            "minLength": 3,
            "type": "string"
          },
          "entity": {
            "maxLength": 40,
            "minLength": 3,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "ActionResult": {
        "type": "object",
        "additionalProperties": false
      },
      "AggregateFunction": {
        "enum": [
          "count",
          "count_distinct",
          "sum",
          "total",
          "avg",
          "min",
          "max",
          "group_concat"
        ],
        "type": "string",
        "description": "Aggregation function type"
      },
      "Aggregation": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AggregateFunction"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias, if any, for the Aggregate expression when selected",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "How to aggregate over a field"
      },
      "AutoDetectType": {
        "enum": [
          "Auto",
          "SpecifyColumnsYetInferTypes",
          "SpecifyColumnsAndTypes"
        ],
        "type": "string",
        "description": "The method of name/type column inference being used"
      },
      "AvailableField": {
        "required": [
          "fieldType",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the Field"
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "fieldType": {
            "$ref": "#/components/schemas/FieldType"
          },
          "isMain": {
            "type": "boolean",
            "description": "Is this a Main Field within the Provider",
            "nullable": true
          },
          "isPrimaryKey": {
            "type": "boolean",
            "description": "Is this a member of the PrimaryKey of the Provider",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "AvailableParameter": {
        "required": [
          "fields",
          "parameterName",
          "providerName"
        ],
        "type": "object",
        "properties": {
          "providerName": {
            "minLength": 1,
            "type": "string",
            "description": "Name of the Provider with a TableParameter"
          },
          "parameterName": {
            "minLength": 1,
            "type": "string",
            "description": "Name of the TableParameter on the Provider"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MappableField"
            },
            "description": "Fields that can be mapped to"
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "BackgroundMultiQueryProgressResponse": {
        "type": "object",
        "properties": {
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundMultiQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "format": "uuid",
            "readOnly": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json (as a string) data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchJsonProper": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json-proper data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchXml": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Xml data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchParquet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Parquet data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchCsv": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "CSV data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchPipe": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Pipe delimited data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchExcel": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Excel workbook data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchSqlite": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "SqLite DB data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Histogram links for all of the child queries",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryCancelResponse": {
        "type": "object",
        "properties": {
          "hadData": {
            "type": "boolean"
          },
          "previousStatus": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "previousState": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryProgressResponse": {
        "type": "object",
        "properties": {
          "hasData": {
            "type": "boolean",
            "description": "Is there currently data for this Query?"
          },
          "rowCount": {
            "type": "integer",
            "description": "Number of rows of data held. -1 if none as yet.",
            "format": "int32"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "state": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "The LuminesceSql of the original request",
            "nullable": true
          },
          "queryName": {
            "type": "string",
            "description": "The QueryName given in the original request",
            "nullable": true
          },
          "columnsAvailable": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Column"
            },
            "description": "When HasData is true this is the schema of columns that will be returned if the data is requested",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "description": "ExecutionId of the started-query",
            "nullable": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJsonProper": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchXml": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchParquet": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchCsv": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchPipe": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchExcel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchSqlite": {
            "$ref": "#/components/schemas/Link"
          },
          "histogram": {
            "$ref": "#/components/schemas/Link"
          }
        },
        "additionalProperties": false,
        "description": "Response for Background Query Start requests"
      },
      "BackgroundQueryState": {
        "enum": [
          "New",
          "Running",
          "Errored",
          "Cancelled",
          "Executed",
          "ExecutedNoSerializationRequired",
          "Serialized",
          "SerializationFailed",
          "AttemptingToDeserialize",
          "Loaded",
          "Cleared",
          "Disposed",
          "OwnerTerminated"
        ],
        "type": "string"
      },
      "CaseStatementDesign": {
        "type": "object",
        "properties": {
          "selectedField": {
            "type": "string",
            "description": "Selected field in the SQL query.",
            "nullable": true
          },
          "caseStatementItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CaseStatementItem"
            },
            "description": "A list containing the filter, source, and target.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of the selected field and a list of: filter, source, and target."
      },
      "CaseStatementItem": {
        "required": [
          "filter",
          "source",
          "target"
        ],
        "type": "object",
        "properties": {
          "filter": {
            "minLength": 1,
            "type": "string",
            "description": "The operator in the case statement SQL expression"
          },
          "source": {
            "minLength": 1,
            "type": "string",
            "description": "The expression that is on the LHS of the operator\r\nA typical case statement would look like:\r\nCASE Field {Filter} Source THEN Target"
          },
          "target": {
            "minLength": 1,
            "type": "string",
            "description": "The expression that is on the RHS of the operator\r\nA typical case statement would look like:\r\nCASE Field {Filter} Source THEN Target"
          },
          "isTargetNonLiteral": {
            "type": "boolean",
            "description": "The Target can be a literal value or a non literal (field) and\r\nhence will be interpreted differently.\r\nThis can be determined from the UI and passed down as a true / false"
          }
        },
        "additionalProperties": false,
        "description": "Information about a case statement.\r\nA typical case statement would look like:\r\nCASE WHEN Field {Filter} Source THEN Target\r\nFor example: CASE WHEN 'currency' = 'USD' THEN 'US'\r\nHere the Field is 'currency', the Source is 'USD', the Filter is '=', and the Target is 'US'"
      },
      "CertificateAction": {
        "enum": [
          "Create",
          "CreateAndAllowMultipleWhichAreValid",
          "Renew",
          "Revoke"
        ],
        "type": "string",
        "description": "The action to take with a certificate"
      },
      "CertificateFileType": {
        "enum": [
          "Public",
          "Private"
        ],
        "type": "string",
        "description": "The type of the certificate file to be downloaded (both public and private are needed to connect)"
      },
      "CertificateState": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The \"key\" to which this belongs in the dictionary,\r\nbasically the CN without any version information",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "description": "The version of this certificate",
            "format": "int32"
          },
          "commonName": {
            "type": "string",
            "description": "The common Name of the Certificate",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/CertificateType"
          },
          "creationStatus": {
            "$ref": "#/components/schemas/CertificateStatus"
          },
          "revocationStatus": {
            "$ref": "#/components/schemas/CertificateStatus"
          },
          "validityStart": {
            "type": "string",
            "description": "The earliest point at which a certificate can be used",
            "format": "date-time",
            "nullable": true
          },
          "validityEnd": {
            "type": "string",
            "description": "The latest point at which a certificate can be used",
            "format": "date-time",
            "nullable": true
          },
          "revokedAt": {
            "type": "string",
            "description": "The point at which this was revoked, if any",
            "format": "date-time",
            "nullable": true
          },
          "revokedBy": {
            "type": "string",
            "description": "The user which revoked this, if any",
            "nullable": true
          },
          "createdAt": {
            "type": "string",
            "description": "The point at which this was created",
            "format": "date-time",
            "nullable": true
          },
          "createdBy": {
            "type": "string",
            "description": "The user which created this",
            "nullable": true
          },
          "serialNumber": {
            "type": "string",
            "description": "The Vault-issued serial number of the certificate, if any - used for revocation",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "The location within Configuration Store that this is saved to",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information held about the minting / revoking of a certificate.\r\nIt does *not* contain the certificate itself"
      },
      "CertificateStatus": {
        "enum": [
          "None",
          "WebApiPersistence",
          "Vault",
          "Rabbit",
          "ConfigStore",
          "AllSystems"
        ],
        "type": "string",
        "description": "Which System(s) have been updated with a given request"
      },
      "CertificateType": {
        "enum": [
          "Domain",
          "User"
        ],
        "type": "string",
        "description": "The sort of certificate being Created / Revoked / Renewed"
      },
      "Column": {
        "type": "object",
        "properties": {
          "isPrimaryKey": {
            "type": "boolean"
          },
          "isMain": {
            "type": "boolean"
          },
          "isRequiredByProvider": {
            "type": "boolean"
          },
          "mandatoryForActions": {
            "type": "string",
            "nullable": true
          },
          "clientIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "conditionUsage": {
            "$ref": "#/components/schemas/ConditionAttributes"
          },
          "sampleValues": {
            "type": "string",
            "nullable": true
          },
          "allowedValues": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ColumnInfo": {
        "type": "object",
        "properties": {
          "select": {
            "type": "boolean",
            "description": "Should the column be used/selected?"
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The name of the column",
            "nullable": true
          },
          "xPath": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Xpath for the column (only applicable to XML defined columns)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "ConditionAttributes": {
        "enum": [
          "None",
          "Normal",
          "Required",
          "Main"
        ],
        "type": "string"
      },
      "ConvertToViewData": {
        "required": [
          "name",
          "query"
        ],
        "type": "object",
        "properties": {
          "query": {
            "minLength": 1,
            "type": "string",
            "description": "view query"
          },
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of view"
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Description of view",
            "nullable": true
          },
          "documentationLink": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Documentation link",
            "nullable": true
          },
          "viewParameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ViewParameter"
            },
            "description": "View parameters",
            "nullable": true
          },
          "otherParameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "description": "Other parameters not explicitly handled by the ConvertToView generation.\r\nThese will be populated by the \"From SQL\" and should simply be returned by\r\nthe web GUI should the user edit / update / regenerate",
            "nullable": true
          },
          "startingVariableName": {
            "type": "string",
            "description": "Which variable the this start with, null if not started from a full Create View Sql Statement.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of view data where will template the data into a 'create view' sql"
      },
      "CursorPosition": {
        "required": [
          "column",
          "row"
        ],
        "type": "object",
        "properties": {
          "row": {
            "type": "integer",
            "description": "Row (0 based) of the user's cursor position",
            "format": "int32"
          },
          "column": {
            "type": "integer",
            "description": "Column (0 based) of the user's cursor position",
            "format": "int32"
          }
        },
        "additionalProperties": false,
        "description": "Represents a cursor location"
      },
      "DataType": {
        "enum": [
          "Boolean",
          "Date",
          "DateTime",
          "Decimal",
          "Double",
          "Int",
          "BigInt",
          "Text",
          "Table"
        ],
        "type": "string"
      },
      "ErrorHighlightItem": {
        "required": [
          "length",
          "message",
          "start",
          "stop"
        ],
        "type": "object",
        "properties": {
          "start": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "stop": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "noViableAlternativeStart": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "length": {
            "type": "integer",
            "description": "The length of the error token counting line breaks if any",
            "format": "int32"
          },
          "message": {
            "minLength": 1,
            "type": "string",
            "description": "The error message"
          }
        },
        "additionalProperties": false,
        "description": "Representation of a sql error"
      },
      "ErrorHighlightRequest": {
        "required": [
          "lines"
        ],
        "type": "object",
        "properties": {
          "lines": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The lines of text the user currently has in the editor"
          },
          "ensureSomeTextIsSelected": {
            "type": "boolean",
            "description": "If an editor requires some selection of non-whitespace this can be set to true to force\r\nat least one visible character to be selected."
          }
        },
        "additionalProperties": false,
        "description": "Request for Error highlighting"
      },
      "ErrorHighlightResponse": {
        "required": [
          "errors",
          "sqlWithMarker"
        ],
        "type": "object",
        "properties": {
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ErrorHighlightItem"
            },
            "description": "The errors within the Sql"
          },
          "sqlWithMarker": {
            "minLength": 1,
            "type": "string",
            "description": "The SQL this is for, with characters indicating the error locations"
          }
        },
        "additionalProperties": false,
        "description": "Response for error highlighting"
      },
      "ExpressionWithAlias": {
        "required": [
          "expression"
        ],
        "type": "object",
        "properties": {
          "expression": {
            "minLength": 1,
            "type": "string",
            "description": "Expression (column name, constant, complex expression, etc.)"
          },
          "alias": {
            "type": "string",
            "description": "Column Alias for the expression",
            "nullable": true
          },
          "flags": {
            "$ref": "#/components/schemas/MappingFlags"
          }
        },
        "additionalProperties": false,
        "description": "Contract for an expression of data we \"have\" that we may \"want to map to a table-parameter's column\""
      },
      "FeedbackEventArgs": {
        "type": "object",
        "properties": {
          "when": {
            "type": "string",
            "format": "date-time"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid"
          },
          "executionId": {
            "type": "string",
            "format": "uuid"
          },
          "level": {
            "$ref": "#/components/schemas/FeedbackLevel"
          },
          "sender": {
            "type": "string",
            "nullable": true
          },
          "stateId": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "messageTemplate": {
            "type": "string",
            "nullable": true
          },
          "propertyValues": {
            "type": "array",
            "items": {},
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "FeedbackLevel": {
        "enum": [
          "None",
          "Progress",
          "Debug",
          "Information",
          "Warning",
          "Error",
          "ProgressAndError",
          "ProgressAndWarning",
          "ProgressAndInformation",
          "ProgressAndDebug",
          "ExecutionKeepAlive"
        ],
        "type": "string"
      },
      "FieldDesign": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the Field"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias if any (if none the Name is used)",
            "nullable": true
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "shouldSelect": {
            "type": "boolean",
            "description": "Should this be selected? False would imply it is only being filtered on.\r\nIgnored when Aggregations are present"
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilterTermDesign"
            },
            "description": "Filter clauses to apply to this field (And'ed together)",
            "nullable": true
          },
          "aggregations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Aggregation"
            },
            "description": "Aggregations to apply (as opposed to simply selecting)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Treatment of a single field within a QueryDesign"
      },
      "FieldType": {
        "enum": [
          "Column",
          "Parameter"
        ],
        "type": "string"
      },
      "FileReaderBuilderDef": {
        "type": "object",
        "properties": {
          "autoDetect": {
            "$ref": "#/components/schemas/AutoDetectType"
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "Column information for the results",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "description": "What limit be added to the load query?  Less than or equal to zero means none",
            "format": "int32"
          },
          "source": {
            "$ref": "#/components/schemas/Source"
          },
          "availableSources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Source"
            },
            "description": "The source locations the user has access to.  The provider in essence.",
            "nullable": true
          },
          "variableName": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The name of the variable for the `use` statement",
            "nullable": true
          },
          "filePath": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The file (or folder) path",
            "nullable": true
          },
          "folderFilter": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The filter to apply to a folder (all matching files then being read) a RegExp",
            "nullable": true
          },
          "zipFilter": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The filter to apply to folder structures with zip archives (all matching files then being read) a RegExp",
            "nullable": true
          },
          "addFileName": {
            "type": "boolean",
            "description": "Should a file name column be added to the output?"
          },
          "csv": {
            "$ref": "#/components/schemas/OptionsCsv"
          },
          "excel": {
            "$ref": "#/components/schemas/OptionsExcel"
          },
          "sqLite": {
            "$ref": "#/components/schemas/OptionsSqLite"
          },
          "xml": {
            "$ref": "#/components/schemas/OptionsXml"
          },
          "parquet": {
            "$ref": "#/components/schemas/OptionsParquet"
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "FileReaderBuilderResponse": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "The generated SQL",
            "nullable": true
          },
          "error": {
            "type": "string",
            "description": "The error from running generated SQL Query, if any",
            "nullable": true
          },
          "columns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnInfo"
            },
            "description": "Column information for the results",
            "nullable": true
          },
          "data": {
            "description": "The resulting data from running the Query",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information on how to construct a file-read sql query"
      },
      "FilterTermDesign": {
        "required": [
          "operator",
          "value"
        ],
        "type": "object",
        "properties": {
          "operator": {
            "$ref": "#/components/schemas/QueryDesignerBinaryOperator"
          },
          "value": {
            "maxLength": 2048,
            "minLength": 0,
            "type": "string",
            "description": "The value to compare against (always as a string, but will be formatted to the correct type)"
          }
        },
        "additionalProperties": false,
        "description": "A single filter clause"
      },
      "IdSelectorDefinition": {
        "required": [
          "actions",
          "identifier"
        ],
        "type": "object",
        "properties": {
          "identifier": {
            "minLength": 1,
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "actions": {
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActionId"
            }
          },
          "name": {
            "maxLength": 100,
            "minLength": 0,
            "type": "string",
            "nullable": true
          },
          "description": {
            "maxLength": 1024,
            "minLength": 0,
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "InlinedPropertyDesign": {
        "type": "object",
        "properties": {
          "providerName": {
            "type": "string",
            "description": "The provider name for which these properties are to be inlined",
            "nullable": true
          },
          "inlinedPropertyItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/InlinedPropertyItem"
            },
            "description": "Collection of Inlined properties",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of a set of inlined properties for a given provider so that SQL can be generated to be able to inline properties into luminesce"
      },
      "InlinedPropertyItem": {
        "required": [
          "key"
        ],
        "type": "object",
        "properties": {
          "key": {
            "minLength": 1,
            "type": "string",
            "description": "Key of the property"
          },
          "name": {
            "type": "string",
            "description": "Name of the property",
            "nullable": true
          },
          "isMain": {
            "type": "boolean",
            "description": "Is Main indicator for the property"
          },
          "description": {
            "type": "string",
            "description": "Description of the property",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Information about a inlined property so that decorated properties can be inlined into luminesce"
      },
      "IntellisenseItem": {
        "required": [
          "caption",
          "value"
        ],
        "type": "object",
        "properties": {
          "caption": {
            "minLength": 1,
            "type": "string",
            "description": "The value to show the user in the popup"
          },
          "value": {
            "minLength": 1,
            "type": "string",
            "description": "The value to substitute in"
          },
          "meta": {
            "type": "string",
            "description": "The light-grey text shown to the right of the Caption in the popup",
            "nullable": true
          },
          "score": {
            "type": "integer",
            "description": "How important is this.  Bigger is more important.",
            "format": "int32"
          },
          "docHTML": {
            "type": "string",
            "description": "Popup further info (as in a whole documentation article!)",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/IntellisenseType"
          }
        },
        "additionalProperties": false,
        "description": "Representation of an item in an Intellisense popup"
      },
      "IntellisenseRequest": {
        "required": [
          "lines",
          "position"
        ],
        "type": "object",
        "properties": {
          "lines": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The lines of text the user currently has in the editor"
          },
          "position": {
            "$ref": "#/components/schemas/CursorPosition"
          }
        },
        "additionalProperties": false,
        "description": "Representation of a request for IntellisenseItems"
      },
      "IntellisenseResponse": {
        "required": [
          "autoCompleteList",
          "endReplacementPosition",
          "sqlWithMarker",
          "startReplacementPosition",
          "tryAgainSoonForMore"
        ],
        "type": "object",
        "properties": {
          "autoCompleteList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntellisenseItem"
            },
            "description": "The available items at this point"
          },
          "tryAgainSoonForMore": {
            "type": "boolean",
            "description": "Should the caller try again soon? (true means a cache is being built and this is a preliminary response!)"
          },
          "sqlWithMarker": {
            "minLength": 1,
            "type": "string",
            "description": "The SQL this is for with characters indicating the location the pop-up is for"
          },
          "startReplacementPosition": {
            "$ref": "#/components/schemas/CursorPosition"
          },
          "endReplacementPosition": {
            "$ref": "#/components/schemas/CursorPosition"
          }
        },
        "additionalProperties": false,
        "description": "Available intellisense response information"
      },
      "IntellisenseType": {
        "enum": [
          "Keyword",
          "Symbol",
          "Function",
          "Operator",
          "Table",
          "Column",
          "Parameter",
          "ScalarVariable"
        ],
        "type": "string"
      },
      "Link": {
        "required": [
          "href",
          "method",
          "relation"
        ],
        "type": "object",
        "properties": {
          "relation": {
            "type": "string"
          },
          "href": {
            "type": "string",
            "format": "uri"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "method": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "LuminesceBinaryType": {
        "enum": [
          "CommandLineTool",
          "LocalFileSystem_Providers",
          "Email_Providers",
          "Python_Providers",
          "AwsS3_Providers",
          "Azure_Providers",
          "SqlDb_Providers_Db2Linux",
          "SqlDb_Providers_MySql",
          "SqlDb_Providers_Oracle",
          "SqlDb_Providers_Oracle_Snowflake",
          "SqlDb_Providers_Postgresql",
          "SqlDb_Providers_Snowflake",
          "SqlDb_Providers_SqlServer",
          "SqlDb_Providers_SybaseAse",
          "SqlDb_Providers_SqLite",
          "SqlDb_Providers_DuckDb",
          "SqlDb_Providers_AwsDynamoDb",
          "SqlDb_Providers_SqlServer_Oracle",
          "Jdbc_Driver",
          "PowerBi_Connector",
          "Odbc_Win64_Driver"
        ],
        "type": "string",
        "description": "Binaries that can be downloaded"
      },
      "LusidProblemDetails": {
        "required": [
          "code",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "minLength": 1,
            "type": "string"
          },
          "errorDetails": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "nullable": true
          },
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MappableField": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the field in need of mapping (The field name from within the Table Parameter itself)",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "description": {
            "type": "string",
            "description": "Description of the field (just for rendering to the user)",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Display Name of the field (just for rendering to the user)",
            "nullable": true
          },
          "sampleValues": {
            "type": "string",
            "description": "Example values for the field (just for rendering to the user)",
            "nullable": true
          },
          "allowedValues": {
            "type": "string",
            "description": "Any set of exactly allowed values for the field (perhaps just for rendering to the user, if nothing else)",
            "nullable": true
          },
          "mandatoryForActions": {
            "type": "string",
            "description": "Which `Actions` is this mandatory for? If any (and potentially when), perhaps just for rendering to the user, if nothing else",
            "nullable": true
          },
          "mapping": {
            "$ref": "#/components/schemas/ExpressionWithAlias"
          }
        },
        "additionalProperties": false,
        "description": "Information about a field that can be designed on (regardless if it currently is)\r\nKind of a \"mini-available catalog entry\""
      },
      "MappingFlags": {
        "enum": [
          "None",
          "Exact",
          "Similar",
          "Additional"
        ],
        "type": "string"
      },
      "MultiQueryDefinitionType": {
        "enum": [
          "Instrument",
          "Expiry",
          "CorporateActions",
          "EdiInstrument",
          "EdiInstrumentWriter",
          "Testing",
          "MarketplaceClientLoadHistory",
          "InsightsMetricsEntitlement",
          "InstrumentDiscovery",
          "InstrumentUpsert"
        ],
        "type": "string"
      },
      "OptionsCsv": {
        "type": "object",
        "properties": {
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "columnNamesWanted": {
            "type": "string",
            "description": "Column (by Name) that should be returned (comma delimited list)",
            "nullable": true
          },
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "noHeader": {
            "type": "boolean",
            "description": "Set this if there is no header row"
          },
          "delimiter": {
            "type": "string",
            "description": "The delimiter between values (\\t for tab)",
            "nullable": true
          },
          "escape": {
            "type": "string",
            "description": "Character used to escape the 'Quote' character when within a value",
            "nullable": true
          },
          "quote": {
            "type": "string",
            "description": "Character used around any field containing the 'delimiter' or a line break.",
            "nullable": true
          },
          "valuesToMakeNull": {
            "type": "string",
            "description": "Regex of values to map to 'null' in the returned data.",
            "nullable": true
          },
          "skipPreHeader": {
            "type": "integer",
            "description": "Number of rows to ignore before the header row",
            "format": "int32"
          },
          "skipPostHeader": {
            "type": "integer",
            "description": "Number of rows to ignore after the header row",
            "format": "int32"
          },
          "skipInvalidRows": {
            "type": "boolean",
            "description": "Skip invalid data rows (totally invalid ones), \r\nThis also allows for potentially wrong data if it can be handled somewhat e.g. embedded quotes misused (and still returns such rows).\r\nIn either case a warning will show in the progress feedback."
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsExcel": {
        "type": "object",
        "properties": {
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "noHeader": {
            "type": "boolean",
            "description": "Set this if there is no header row"
          },
          "calculate": {
            "type": "boolean",
            "description": "Whether to attempt a calculation of the imported cell range prior to import"
          },
          "password": {
            "type": "string",
            "description": "If specified will be used as the password used for password protected workbooks",
            "nullable": true
          },
          "worksheet": {
            "type": "string",
            "description": "The worksheet containing the cell range to import (name or index, will default to first)",
            "nullable": true
          },
          "rangeOrTable": {
            "type": "string",
            "description": "The cell range to import as either a specified range or a table name",
            "nullable": true
          },
          "ignoreInvalidCells": {
            "type": "boolean",
            "description": "If specified cells which can not be successfully converted to the target type will be ignored"
          },
          "ignoreBlankRows": {
            "type": "boolean",
            "description": "If the entire rows has only blank cells it will be ignored will be ignored"
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsParquet": {
        "type": "object",
        "properties": {
          "columnNamesWanted": {
            "type": "string",
            "description": "Column (by Name) that should be returned (comma delimited list)",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsSqLite": {
        "type": "object",
        "properties": {
          "table": {
            "type": "string",
            "description": "Table name to read.  If missing then an error will be raised if there is any number of tables other than one.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OptionsXml": {
        "type": "object",
        "properties": {
          "columnTypes": {
            "type": "string",
            "description": "Column types (comma delimited list of: '{types}', some columns may be left blank while others are specified)",
            "nullable": true
          },
          "inferTypeRowCount": {
            "type": "integer",
            "description": "If non-zero and 'types' is not specified (or not specified for some columns) this will look through N rows to attempt to work out the column types for columns not pre-specified",
            "format": "int32"
          },
          "valuesToMakeNull": {
            "type": "string",
            "description": "Regex of values to map to 'null' in the returned data.",
            "nullable": true
          },
          "columnNames": {
            "type": "string",
            "description": "Column Names either overrides the header row or steps in when there is no header row (comma delimited list)",
            "nullable": true
          },
          "nodePath": {
            "type": "string",
            "description": "XPath query that selects the nodes to map to rows",
            "nullable": true
          },
          "namespaces": {
            "type": "string",
            "description": "Selected prefix(es) and namespace(s):prefix1=namespace1-uri1,prefix2=namespace2-uri2,...prefixN=namespaceN-uriN",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Additional options applicable to the given SourceType"
      },
      "OrderByDirection": {
        "enum": [
          "asc",
          "desc"
        ],
        "type": "string",
        "description": "Direction of Order By terms in the Order By clause"
      },
      "OrderByTermDesign": {
        "required": [
          "field"
        ],
        "type": "object",
        "properties": {
          "field": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the field to order by"
          },
          "direction": {
            "$ref": "#/components/schemas/OrderByDirection"
          }
        },
        "additionalProperties": false,
        "description": "A single clause within an Order BY"
      },
      "QueryDesign": {
        "required": [
          "fields",
          "tableName"
        ],
        "type": "object",
        "properties": {
          "tableName": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the table being designed"
          },
          "alias": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Alias for the table in the generated SQL, if any",
            "nullable": true
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldDesign"
            },
            "description": "Fields to be selected, aggregated over and/or filtered on"
          },
          "orderBy": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OrderByTermDesign"
            },
            "description": "Order By clauses to apply",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "description": "Row limit to apply, if any",
            "format": "int32",
            "nullable": true
          },
          "warnings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Any warnings to show the user when converting from SQL to this representation",
            "nullable": true
          },
          "availableFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailableField"
            },
            "description": "Fields that are known to be available for design when parsing SQL",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of a \"designable Query\" suitable for formatting to SQL or being built from compliant SQL."
      },
      "QueryDesignerBinaryOperator": {
        "enum": [
          "Lt",
          "Lte",
          "Gt",
          "Gte",
          "Eq",
          "Neq",
          "Like",
          "Contains",
          "StartsWith",
          "EndsWith"
        ],
        "type": "string"
      },
      "ResourceListOfAccessControlledResource": {
        "required": [
          "values"
        ],
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResource"
            }
          },
          "href": {
            "type": "string",
            "format": "uri",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "nullable": true
          },
          "nextPage": {
            "type": "string",
            "nullable": true
          },
          "previousPage": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ScalarParameter": {
        "required": [
          "name",
          "type"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the scalar parameter"
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "value": {
            "description": "the default value of the parameter",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Describes a scalar parameter as defined in the SQL"
      },
      "Source": {
        "type": "object",
        "properties": {
          "location": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "The source location.  Start of a provider name, `Drive`, `LocalFs`, `AwsS3` etc.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/SourceType"
          }
        },
        "additionalProperties": false,
        "description": "Information leading to choosing the provider"
      },
      "SourceType": {
        "enum": [
          "Unknown",
          "Csv",
          "Excel",
          "SqLite",
          "Xml",
          "Parquet",
          "RawText"
        ],
        "type": "string",
        "description": "The file type of a source"
      },
      "TaskStatus": {
        "enum": [
          "Created",
          "WaitingForActivation",
          "WaitingToRun",
          "Running",
          "WaitingForChildrenToComplete",
          "RanToCompletion",
          "Canceled",
          "Faulted"
        ],
        "type": "string"
      },
      "ViewParameter": {
        "required": [
          "dataType",
          "name",
          "value"
        ],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Name of the provider"
          },
          "dataType": {
            "$ref": "#/components/schemas/DataType"
          },
          "value": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Value of the provider"
          },
          "isTableDataMandatory": {
            "type": "boolean",
            "description": "Should this be selected? False would imply it is only being filtered on.\r\nIgnored when Aggregations are present"
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Description of the parameter",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Parameters of view"
      },
      "WriterDesign": {
        "required": [
          "sql"
        ],
        "type": "object",
        "properties": {
          "sql": {
            "minLength": 1,
            "type": "string",
            "description": "Original SQL that started this off"
          },
          "availableToMapFrom": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExpressionWithAlias"
            },
            "description": "The data able to be mapped from as derived from the Sql",
            "nullable": true
          },
          "parameter": {
            "$ref": "#/components/schemas/AvailableParameter"
          },
          "availableParameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailableParameter"
            },
            "description": "All the parameter the user may wish to design",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Representation of a \"designable Query for a writer\" suitable for formatting to SQL or being built from compliant SQL."
      }
    },
    "securitySchemes": {
      "oauth2": {
        "type": "oauth2",
        "description": "OAuth2 Implicit Grant",
        "flows": {
          "implicit": {
            "authorizationUrl": "https://lusid-fbn-ci.okta.com/oauth2/aus49h9b8rQPvouCH2p7/v1/authorize",
            "scopes": {}
          }
        }
      }
    }
  },
  "security": [
    {}
  ],
  "tags": [
    {
      "name": "Application Metadata",
      "description": "Metadata about the application"
    },
    {
      "name": "Binary Downloading",
      "description": "Allows for the downloading of Luminesce Binaries, given the required entitlements.\nThese are to allow various functionalities to be run outside of Finbourne cloud infrastructure.\nFor example to connection to internal databases, run providers on users' machines, or obtain the LuminesceCLI."
    },
    {
      "name": "Certificate Management",
      "description": "List / Mint / Renew / Revoke Luminesce TLS Certs"
    },
    {
      "name": "Current Table/Field Catalog",
      "description": "Table/Field information on available Providers"
    },
    {
      "name": "Health checking endpoint",
      "description": "Allows for checking health"
    },
    {
      "name": "Historically Executed Queries",
      "description": "Shows queries executed at some point and details about them"
    },
    {
      "name": "Multi-Query Execution",
      "description": "This executes a series of internally defined LuminesceSql statements in the background"
    },
    {
      "name": "Sql Background Execution",
      "description": "This executes LuminesceSql and allows monitoring its completion"
    },
    {
      "name": "Sql Design",
      "description": "This has methods for Designing SQL (to support the Web GUI designer interfaces) for pretty-printing of sql, etc."
    },
    {
      "name": "Sql Execution",
      "description": "This executes LuminesceSql synchronously, allows for returning the resulting data in various formats."
    }
  ],
  "x-tagGroups": {
    "name": "API",
    "tags": [
      "Application Metadata",
      "Binary Downloading",
      "Certificate Management",
      "Current Table/Field Catalog",
      "Health checking endpoint",
      "Historically Executed Queries",
      "Multi-Query Execution",
      "Sql Background Execution",
      "Sql Design",
      "Sql Execution"
    ]
  }
}
