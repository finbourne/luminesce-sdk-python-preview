{
  "openapi": "3.0.1",
  "info": {
    "title": "FINBOURNE Luminesce Web API",
    "termsOfService": "https://www.finbourne.com/legal/terms-conditions",
    "contact": {
      "name": "FINBOURNE Technology",
      "url": "https://www.finbourne.com",
      "email": "info@finbourne.com"
    },
    "version": "1.11.304",
    "x-logo": {
      "url": "https://www.lusid.com/app/assets/logo_white.png",
      "backgroundColor": "#415464"
    },
    "description": "FINBOURNE Technology"
  },
  "servers": [
    {
      "url": "https://www.lusid.com/honeycomb"
    }
  ],
  "paths": {
    "/api/Catalog": {
      "get": {
        "tags": [
          "Current Table/Field Catalog"
        ],
        "summary": "GetCatalog: Shows Table and Field level information on Providers that are currently running that you have access to (in Json format)",
        "description": "\nThe following LuminesceSql is executed to return this information:\n\n```sql\n@reg =\nselect\n    r.Name,\n    min(r.Description) as Description\nfrom\n    Sys.Registration r\nwhere\n    r.Type in ('DirectProvider', 'DataProvider')\n    and \n    r.ShowAll = false\ngroup by\n    1\n    ;\n\n@fld =\nselect\n    f.TableName,\n    f.FieldName,\n    f.DataType,\n    f.FieldType,\n    f.IsPrimaryKey,\n    f.IsMain,\n    f.Description,\n    f.ParamDefaultValue,\n    f.TableParamColumns\nfrom\n    Sys.Field f\n    ;\n\n@x =\nselect\n    coalesce(f.TableName, r.Name) as TableName,\n    coalesce(f.FieldName, 'N/A') as FieldName,\n    f.DataType,\n    f.FieldType,\n    f.IsPrimaryKey,\n    f.IsMain,\n    case \n        when f.TableName is not null \n            then f.Description\n        else\n            r.Name || ' returns a different set of columns depending on use.'\n        end as Description,\n    f.ParamDefaultValue,\n    f.TableParamColumns,\n    r.Description as ProviderDescription\nfrom\n    @reg r\n    left outer join @fld f\n        on r.Name = f.TableName\norder by\n    1, 5 desc, 6 desc, 2\n    ;\n   \n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n",
        "operationId": "GetCatalog",
        "parameters": [
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Limit the catalog to only things in some way dealing with the passed in text string",
            "schema": {
              "type": "string",
              "description": "Limit the catalog to only things in some way dealing with the passed in text string",
              "nullable": true
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetHistory: Shows queries executed in a given historical time window (in Json format).",
        "description": "\nStarts to load the historical query logs for a certain time range, search criteria, etc.\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n",
        "operationId": "GetHistory",
        "parameters": [
          {
            "name": "startAt",
            "in": "query",
            "description": "Date time to start the search from.  Will default to Now - 1 Day",
            "schema": {
              "type": "string",
              "description": "Date time to start the search from.  Will default to Now - 1 Day",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "Date time to end the search at.  Defaults to now.",
            "schema": {
              "type": "string",
              "description": "Date time to end the search at.  Defaults to now.",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "freeTextSearch",
            "in": "query",
            "description": "Some test that must be in at least one field returned.",
            "schema": {
              "type": "string",
              "description": "Some test that must be in at least one field returned.",
              "nullable": true
            }
          },
          {
            "name": "showAll",
            "in": "query",
            "description": "For users with extra permissions, they may optionally see other users' queries.",
            "schema": {
              "type": "boolean",
              "description": "For users with extra permissions, they may optionally see other users' queries.",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "202": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "GetProgressOfHistory: View progress information (up until this point) of a history query",
        "description": "View progress information (up until this point) of previously started History query\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "CancelHistory: Cancels (if running) or clears the data from (if completed) a previously started History query",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelHistory",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/histogram": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
              "format": "date-span",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/History/{executionId}/json": {
      "get": {
        "tags": [
          "Historically Executed Queries"
        ],
        "summary": "FetchHistoryResultJson: Fetches the result from a previously started query, in JSON format.",
        "description": "Fetch the data in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchHistoryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "description": "When paginating, only return this number of records, page should also be specified.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/metadata/access/resources": {
      "get": {
        "tags": [
          "Application Metadata"
        ],
        "summary": "GetServicesAsAccessControlledResources: Get resources available for access control",
        "description": "\nGet the comprehensive set of resources that are available for access control.\n\nThe following LuminesceSql is executed to return this information, \nwhich is then packaged up as AccessControlledResource:\n\n```sql\nselect\n    Name,\n    min(coalesce(Description, Name) || ' (' || Type || ')') as Description\nfrom\n    Sys.Registration\nwhere\n    Type in ('DirectProvider', 'DataProvider')\n    and\n    ShowAll = true\ngroup by 1\norder by 1\n   \n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n",
        "operationId": "GetServicesAsAccessControlledResources",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceListOfAccessControlledResource"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground": {
      "put": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "StartQueries: Starts to Execute the LuminesceSql statements in the background.",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready), on a per result basis\n- view progress information (up until this point), for all results in one go\n- cancel the queries (if still running) / clear the data (if already returned)\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n",
        "operationId": "StartQueries",
        "parameters": [
          {
            "name": "type",
            "in": "query",
            "description": "An enum value defining the set of statements being executed",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MultiQueryDefinitionType"
            }
          },
          {
            "name": "asAt",
            "in": "query",
            "description": "The AsAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "description": "The AsAt time used by any bitemporal provider in the queries.",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "effectiveAt",
            "in": "query",
            "description": "The EffectiveAt time used by any bitemporal provider in the queries.",
            "schema": {
              "type": "string",
              "description": "The EffectiveAt time used by any bitemporal provider in the queries.",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "limit1",
            "in": "query",
            "description": "A limit that is applied to first-level queries (e.g. Instruments themselves)",
            "schema": {
              "type": "integer",
              "description": "A limit that is applied to first-level queries (e.g. Instruments themselves)",
              "format": "int32",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "limit2",
            "in": "query",
            "description": "A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found)",
            "schema": {
              "type": "integer",
              "description": "A limit that is applied to second-level queries (e.g. Holdings based on the set of Instruments found)",
              "format": "int32",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "input1",
            "in": "query",
            "description": "A value available to queries, these vary by 'type' and are only used by some types at all.\r\ne.g. a start-date of some sort",
            "schema": {
              "type": "string",
              "description": "A value available to queries, these vary by 'type' and are only used by some types at all.\r\ne.g. a start-date of some sort",
              "nullable": true
            }
          },
          {
            "name": "input2",
            "in": "query",
            "description": "A second value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string",
              "description": "A second value available to queries, these vary by 'type' and are only used by some types at all.",
              "nullable": true
            }
          },
          {
            "name": "input3",
            "in": "query",
            "description": "A third value available to queries, these vary by 'type' and are only used by some types at all.",
            "schema": {
              "type": "string",
              "description": "A third value available to queries, these vary by 'type' and are only used by some types at all.",
              "nullable": true
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 1200s (20m)",
            "schema": {
              "type": "integer",
              "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 1200s (20m)",
              "format": "int32",
              "default": 0,
              "example": 1200
            },
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
              "format": "int32",
              "default": 0,
              "example": 7200
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "A \"search\" value (e.g. 'Apple' on an instrument search, a `Finbourne.Filtering` expression of Insights, etc.)\r\nIn the cases where \"Nothing\" is valid for a `Finbourne.Filtering` expression, pass `True`.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "A \"search\" value (e.g. 'Apple' on an instrument search, a `Finbourne.Filtering` expression of Insights, etc.)\r\nIn the cases where \"Nothing\" is valid for a `Finbourne.Filtering` expression, pass `True`.",
                "example": "Apple"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/MultiQueryBackground/{executionId}": {
      "get": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "GetProgressOfMultiQuery: View progress information (up until this point) for the entire query-set",
        "description": "View progress information (up until this point) for the entire query-set\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOfMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundMultiQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Multi-Query Execution"
        ],
        "summary": "CancelMultiQuery: Cancels (if running) or clears the data from (if completed) a previously started query-set",
        "description": "Cancel the query-set (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelMultiQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryCsv: Executes Sql, returned in CSV format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "PutByQueryCsv",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Execute (may be multi-line)",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/csv/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryCsv: Executes Sql, returned in CSV format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "GetByQueryCsv",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string",
              "description": "LuminesceSql to Execute (must be one line only)",
              "example": "select ^ from Sys.Field order by 1, 2"
            }
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded), where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "PutByQueryExcel",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Execute (may be multi-line)",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/excel/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryExcel: Executes Sql, returned in Excel (xlsx) format (as a file to be downloaded) format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "GetByQueryExcel",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string",
              "description": "LuminesceSql to Execute (must be one line only)",
              "example": "select ^ from Sys.Field order by 1, 2"
            }
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/json": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryJson: Executes Sql, returned in JSON format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "PutByQueryJson",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Execute (may be multi-line)",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/json/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryJson: Executes Sql, returned in JSON format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "GetByQueryJson",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string",
              "description": "LuminesceSql to Execute (must be one line only)",
              "example": "select ^ from Sys.Field order by 1, 2"
            }
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "PutByQueryPipe",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Execute (may be multi-line)",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pipe/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQueryPipe: Executes Sql, returned in pipe-delimited format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "GetByQueryPipe",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string",
              "description": "LuminesceSql to Execute (must be one line only)",
              "example": "select ^ from Sys.Field order by 1, 2"
            }
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/pretty": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutQueryToFormat: Executes Sql, returned in JSON format, where the sql is the post-body url.",
        "description": "\nThis formats SQL (given a set of options as to how to do so).\nIt takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly)\nand returns the reformatted version.\ne.g.\n```sql\nselect x,y,z from a inner join b on a.x=b.x where x>y or y!=z\n```\nbecomes\n```sql\nselect x, y, z\nfrom a\ninner join b\n   on a.x = b.x\nwhere x > y\n   or y != z\n```\n",
        "operationId": "PutQueryToFormat",
        "parameters": [
          {
            "name": "trailingCommas",
            "in": "query",
            "description": "Should commas be after an expression (as opposed to before)",
            "schema": {
              "type": "boolean",
              "description": "Should commas be after an expression (as opposed to before)",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "uppercaseKeywords",
            "in": "query",
            "description": "Should key words be capitalized",
            "schema": {
              "type": "boolean",
              "description": "Should key words be capitalized",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "breakJoinOnSections",
            "in": "query",
            "description": "Should clauses on joins be given line breaks?",
            "schema": {
              "type": "boolean",
              "description": "Should clauses on joins be given line breaks?",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "spaceAfterExpandedComma",
            "in": "query",
            "description": "Should comma-lists have spaces after the commas?",
            "schema": {
              "type": "boolean",
              "description": "Should comma-lists have spaces after the commas?",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "keywordStandardization",
            "in": "query",
            "description": "Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)",
            "schema": {
              "type": "boolean",
              "description": "Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCommaLists",
            "in": "query",
            "description": "Should comma-lists (e.g. select a,b,c) have line breaks added?",
            "schema": {
              "type": "boolean",
              "description": "Should comma-lists (e.g. select a,b,c) have line breaks added?",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandInLists",
            "in": "query",
            "description": "Should IN-lists have line breaks added?",
            "schema": {
              "type": "boolean",
              "description": "Should IN-lists have line breaks added?",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "expandBooleanExpressions",
            "in": "query",
            "description": "Should boolean expressions have line breaks added?",
            "schema": {
              "type": "boolean",
              "description": "Should boolean expressions have line breaks added?",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandBetweenConditions",
            "in": "query",
            "description": "Should between conditions have line breaks added?",
            "schema": {
              "type": "boolean",
              "description": "Should between conditions have line breaks added?",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "expandCaseStatements",
            "in": "query",
            "description": "Should case-statements have line breaks added?",
            "schema": {
              "type": "boolean",
              "description": "Should case-statements have line breaks added?",
              "default": true
            },
            "x-nullable": true
          },
          {
            "name": "maxLineWidth",
            "in": "query",
            "description": "Maximum number of characters to allow on one line (if possible)",
            "schema": {
              "type": "integer",
              "description": "Maximum number of characters to allow on one line (if possible)",
              "format": "int32",
              "default": 120
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite": {
      "put": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "PutByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded), where the sql is the post-body url.",
        "description": "\nFor more complex LuminesceSql a PUT will allow for longer Sql.\ne.g.:\n```sql\n@@cutoff = select #2020-02-01#;\n@issues = select Id, SortId, Summary, Created, Updated from Dev.Jira.Issue where Project='HC' and Created < @@cutoff and Updated > @@cutoff;\n\nselect i.Id, i.SortId, i.Summary, LinkText, LinkedIssueId, LinkedIssueSortId, LinkedIssueSummary\nfrom @issues i\ninner join Dev.Jira.Issue.Link li\n    on i.Id = li.IssueId\n```\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "PutByQuerySqlite",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "LuminesceSql to Execute (may be multi-line)",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "LuminesceSql to Execute (may be multi-line)",
                "example": "select * from sys.field"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/Sql/sqlite/{query}": {
      "get": {
        "tags": [
          "Sql Execution"
        ],
        "summary": "GetByQuerySqlite: Executes Sql, returned in SqLite DB (sqlite3) format (as a file to be downloaded) format, where the sql is simply in the url.",
        "description": "\nFor simple single-line query execution via the url.\ne.g. `select ^ from Sys.Field order by 1, 2`\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - something failed with the execution or parsing of your query\n- 401 Unauthorized\n",
        "operationId": "GetByQuerySqlite",
        "parameters": [
          {
            "name": "query",
            "in": "path",
            "description": "LuminesceSql to Execute (must be one line only)",
            "required": true,
            "schema": {
              "type": "string",
              "description": "LuminesceSql to Execute (must be one line only)",
              "example": "select ^ from Sys.Field order by 1, 2"
            }
          },
          {
            "name": "queryName",
            "in": "query",
            "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
            "schema": {
              "type": "string",
              "description": "Name to apply to the query in logs and `Sys.Logs.HcQueryStart`",
              "nullable": true,
              "example": "Get tables/fields"
            }
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "In seconds: <0 → ∞, 0 → 120s",
            "schema": {
              "type": "integer",
              "description": "In seconds: <0 → ∞, 0 → 120s",
              "format": "int32",
              "default": 0,
              "example": 120
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground": {
      "put": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "StartQuery: Starts to Execute LuminesceSql in the background.",
        "description": "\nAllow for starting a potentially long running query and getting back an immediate response with how to \n- fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\n- view progress information (up until this point)\n- cancel the query (if still running) / clear the data (if already returned)\n\nThis can still error on things like an outright syntax error, but more runtime errors (e.g. from providers) will not\ncause this to error (that will happen when attempting to fetch data)\n\nHere is an example that intentionally takes one minute to run:\n\n```sql\nselect Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120\n```\n\nThis is the only place in the Luminesce WebAPI where the following is supported.\nThis will allow for the same user running a character-identical query not kick off a new query but simply be returned a reference \nto the already running one for up to `N` seconds (where `N` should be `<=` `keepForSeconds`).\n\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 400 BadRequest - there was something wrong with your query syntax (the issue was detected at parse-time)\n- 401 Unauthorized\n",
        "operationId": "StartQuery",
        "parameters": [
          {
            "name": "queryName",
            "in": "query",
            "description": "A name for this query.  This goes into logs and is available in `Sys.Logs.HcQueryStart`.",
            "schema": {
              "type": "string",
              "description": "A name for this query.  This goes into logs and is available in `Sys.Logs.HcQueryStart`.",
              "nullable": true,
              "example": "Intentionally slow test query"
            }
          },
          {
            "name": "timeoutSeconds",
            "in": "query",
            "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 7200 (2h)",
            "schema": {
              "type": "integer",
              "description": "Maximum time the query may run for, in seconds: <0 → ∞, 0 → 7200 (2h)",
              "format": "int32",
              "default": 0,
              "example": 1200
            },
            "x-nullable": true
          },
          {
            "name": "keepForSeconds",
            "in": "query",
            "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
            "schema": {
              "type": "integer",
              "description": "Maximum time the result may be kept for, in seconds: <0 → 1200 (20m), 0 → 28800 (8h), max = 2,678,400 (31d)",
              "format": "int32",
              "default": 0,
              "example": 7200
            },
            "x-nullable": true
          }
        ],
        "requestBody": {
          "description": "The LuminesceSql query to kick off.",
          "content": {
            "text/plain": {
              "schema": {
                "type": "string",
                "description": "The LuminesceSql query to kick off.",
                "example": "select Str, Takes500Ms from Testing1K where UseLinq = true and [Int] <= 120"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "GetProgressOf: View progress information (up until this point)",
        "description": "View progress information (up until this point)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "GetProgressOf",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      },
      "delete": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "CancelQuery: Cancels (if running) or clears the data from (if completed) a previously started query",
        "description": "Cancel the query (if still running) / clear the data (if already returned)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't exist and is not running.\n",
        "operationId": "CancelQuery",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/BackgroundQueryCancelResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/csv": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultCsv: Fetches the result from a previously started query, in CSV format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultCsv",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "description": "When paginating, only return this number of records, page should also be specified.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/excel": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultExcel: Fetches the result from a previously started query, in Excel format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultExcel",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/histogram": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultHistogram: Fetches the result from a previously started query, converts it to a histogram (counts in buckets).",
        "description": "Fetch the histogram in Json format (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated with standard Problem Detail reports:\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultHistogram",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "timestampFieldName",
            "in": "query",
            "description": "Name of the timestamp field used in building the histogram",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the timestamp field used in building the histogram"
            }
          },
          {
            "name": "startAt",
            "in": "query",
            "description": "Start point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "description": "Start point (of the timestampFieldName field) for the histogram",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "endAt",
            "in": "query",
            "description": "End point (of the timestampFieldName field) for the histogram",
            "schema": {
              "type": "string",
              "description": "End point (of the timestampFieldName field) for the histogram",
              "format": "date-time",
              "nullable": true
            },
            "x-nullable": true
          },
          {
            "name": "bucketSize",
            "in": "query",
            "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
            "schema": {
              "type": "string",
              "description": "Optional histogram bucket width.  If not provided a set number of buckets between start/end range will be generated.",
              "format": "date-span",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "jsonProper",
            "in": "query",
            "description": "Should this be text/json (not json-encoded-as-a-string)",
            "schema": {
              "type": "boolean",
              "description": "Should this be text/json (not json-encoded-as-a-string)",
              "default": false
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/json": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJson: Fetches the result from a previously started query, in JSON string format.\r\nPlease move to '/jsonProper' instead.  This may be marked as Deprecated in the future.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJson",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "description": "When paginating, only return this number of records, page should also be specified.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/jsonProper": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultJsonProper: Fetches the result from a previously started query, in JSON format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultJsonProper",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "description": "When paginating, only return this number of records, page should also be specified.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/pipe": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultPipe: Fetches the result from a previously started query, in pipe-delimited format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultPipe",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "download",
            "in": "query",
            "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
            "schema": {
              "type": "boolean",
              "description": "Makes this a file-download request (as opposed to returning the data in the response-body)",
              "default": false
            },
            "x-nullable": true
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "When paginating, only return this number of records, page should also be specified.",
            "schema": {
              "type": "integer",
              "description": "When paginating, only return this number of records, page should also be specified.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          },
          {
            "name": "page",
            "in": "query",
            "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
            "schema": {
              "type": "integer",
              "description": "0-N based on chunk sized determined by the limit, ignored if limit < 1.",
              "format": "int32",
              "default": 0
            },
            "x-nullable": true
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    },
    "/api/SqlBackground/{executionId}/sqlite": {
      "get": {
        "tags": [
          "Sql Background Execution"
        ],
        "summary": "FetchQueryResultSqlite: Fetches the result from a previously started query, in SqLite format.",
        "description": "Fetch the data in various formats (if available, or if not simply being informed it is not yet ready)\nThe following error codes are to be anticipated most with standard Problem Detail reports:\n- 400 BadRequest : Something failed with the execution of your query\n- 401 Unauthorized\n- 404 Not Found : The requested query result doesn't (yet) exist.\n- 429 Too Many Requests : Please try your request again soon\n  1. The query has been executed successfully in the past yet the server-instance receiving this request (e.g. from a load balancer) doesn't yet have this data available.\n  1. By virtue of the request you have just placed this will have started to load from the persisted cache and will soon be available.\n  1. It is also the case that the original server-instance to process the original query is likely to already be able to service this request.",
        "operationId": "FetchQueryResultSqlite",
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "description": "ExecutionId returned when starting the query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ExecutionId returned when starting the query"
            }
          },
          {
            "name": "sortBy",
            "in": "query",
            "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
            "schema": {
              "type": "string",
              "description": "Order the results by these fields.\r\n            Use the `-` sign to denote descending order, e.g. `-MyFieldName`.  Numeric indexes may be used also, e.g. `2,-3`.\r\n            Multiple fields can be denoted by a comma e.g. `-MyFieldName,AnotherFieldName,-AFurtherFieldName`.\r\n            Default is null, the sort order specified in the query itself.",
              "nullable": true
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "An ODATA filter per Finbourne.Filtering syntax.",
            "schema": {
              "type": "string",
              "description": "An ODATA filter per Finbourne.Filtering syntax.",
              "nullable": true
            }
          },
          {
            "name": "select",
            "in": "query",
            "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
            "schema": {
              "type": "string",
              "description": "Default is null (meaning return all columns in the original query itself).\r\nThe values are in terms of the result column name from the original data set and are comma delimited.\r\nThe power of this comes in that you may aggregate the data if you wish\r\n(that is the main reason for allowing this, in fact).\r\ne.g.:\r\n- `MyField`\r\n- `Max(x) FILTER (WHERE y > 12) as ABC` (max of a field, if another field lets it qualify, with a nice column name)\r\n- `count(*)` (count the rows for the given group, that would produce a rather ugly column name, but  it works)\r\n- `count(distinct x) as numOfXs`\r\nIf there was an illegal character in a field you are selecting from, you are responsible for bracketing it with [ ]. \r\ne.g.\r\n- `some_field, count(*) as a, max(x) as b, min([column with space in name]) as nice_name`\r\n  where you would likely want to pass `1` as the `groupBy` also.",
              "nullable": true
            }
          },
          {
            "name": "groupBy",
            "in": "query",
            "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
            "schema": {
              "type": "string",
              "description": "Groups by the specified fields.\r\n            A comma delimited list of: 1 based numeric indexes (cleaner), or repeats of the select expressions (a bit verbose and must match exactly).\r\n            e.g. `2,3`, `myColumn`.\r\n            Default is null (meaning no grouping will be performed on the selected columns).\r\n            This applies only over the result set being requested here, meaning indexes into the \"select\" parameter fields.\r\n            Only specify this if you are selecting aggregations in the \"select\" parameter.",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              },
              "text/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/LusidProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "oauth2": []
          }
        ],
        "x-fbn-apistatus": "Stable"
      }
    }
  },
  "components": {
    "schemas": {
      "AccessControlledAction": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "nullable": true
          },
          "action": {
            "$ref": "#/components/schemas/ActionId"
          },
          "limitedSet": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdSelectorDefinition"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResource": {
        "type": "object",
        "properties": {
          "application": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledAction"
            },
            "nullable": true
          },
          "identifierParts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResourceIdentifierPartSchemaAttribute"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AccessControlledResourceIdentifierPartSchemaAttribute": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "required": {
            "type": "boolean"
          },
          "valuesPath": {
            "type": "string",
            "nullable": true
          },
          "typeId": {
            "type": "object",
            "additionalProperties": false,
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ActionId": {
        "required": [
          "activity",
          "entity",
          "scope"
        ],
        "type": "object",
        "properties": {
          "scope": {
            "maxLength": 100,
            "minLength": 3,
            "type": "string"
          },
          "activity": {
            "maxLength": 25,
            "minLength": 3,
            "type": "string"
          },
          "entity": {
            "maxLength": 25,
            "minLength": 3,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "BackgroundMultiQueryProgressResponse": {
        "type": "object",
        "properties": {
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackgroundQueryProgressResponse"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundMultiQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "format": "uuid",
            "readOnly": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json (as a string) data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchJsonProper": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Json-proper data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchCsv": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "CSV data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchPipe": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Pipe delimited data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchExcel": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Excel workbook data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "fetchSqlite": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "SqLite DB data request links for all of the child queries",
            "nullable": true,
            "readOnly": true
          },
          "histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Histogram links for all of the child queries",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryCancelResponse": {
        "type": "object",
        "properties": {
          "hadData": {
            "type": "boolean"
          },
          "previousStatus": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "previousState": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryProgressResponse": {
        "type": "object",
        "properties": {
          "hasData": {
            "type": "boolean",
            "description": "Is there currently data for this Query?"
          },
          "rowCount": {
            "type": "integer",
            "description": "Number of rows of data held. -1 if none as yet.",
            "format": "int32"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatus"
          },
          "state": {
            "$ref": "#/components/schemas/BackgroundQueryState"
          },
          "progress": {
            "type": "string",
            "description": "The full progress log (up to this point at least)",
            "nullable": true
          },
          "feedback": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackEventArgs"
            },
            "description": "Individual Feedback Messages (to replace Progress).  A given message will be returned from only one call.",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "The LuminesceSql of the original request",
            "nullable": true
          },
          "queryName": {
            "type": "string",
            "description": "The QueryName given in the original request",
            "nullable": true
          },
          "columnsAvailable": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Column"
            },
            "description": "When HasData is true this is the schema of columns that will be returned if the data is requested",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryResponse": {
        "type": "object",
        "properties": {
          "executionId": {
            "type": "string",
            "nullable": true
          },
          "progress": {
            "$ref": "#/components/schemas/Link"
          },
          "cancel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJson": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchJsonProper": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchCsv": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchPipe": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchExcel": {
            "$ref": "#/components/schemas/Link"
          },
          "fetchSqlite": {
            "$ref": "#/components/schemas/Link"
          },
          "histogram": {
            "$ref": "#/components/schemas/Link"
          }
        },
        "additionalProperties": false
      },
      "BackgroundQueryState": {
        "enum": [
          "New",
          "Running",
          "Errored",
          "Cancelled",
          "Executed",
          "Serialized",
          "SerializationFailed",
          "AttemptingToDeserialize",
          "Loaded",
          "Cleared",
          "Disposed"
        ],
        "type": "string"
      },
      "Column": {
        "type": "object",
        "properties": {
          "isPrimaryKey": {
            "type": "boolean"
          },
          "isMain": {
            "type": "boolean"
          },
          "isRequiredByProvider": {
            "type": "boolean"
          },
          "clientIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "type": {
            "$ref": "#/components/schemas/DataType"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "conditionUsage": {
            "$ref": "#/components/schemas/ConditionAttributes"
          },
          "sampleValues": {
            "type": "string",
            "nullable": true
          },
          "allowedValues": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConditionAttributes": {
        "enum": [
          "None",
          "Normal",
          "Required",
          "Main"
        ],
        "type": "string"
      },
      "DataType": {
        "enum": [
          "Boolean",
          "Int",
          "BigInt",
          "Double",
          "Decimal",
          "Text",
          "Date",
          "DateTime",
          "Table"
        ],
        "type": "string"
      },
      "FeedbackEventArgs": {
        "type": "object",
        "properties": {
          "when": {
            "type": "string",
            "format": "date-time"
          },
          "sessionId": {
            "type": "string",
            "format": "uuid"
          },
          "executionId": {
            "type": "string",
            "format": "uuid"
          },
          "level": {
            "$ref": "#/components/schemas/FeedbackLevel"
          },
          "sender": {
            "type": "string",
            "nullable": true
          },
          "stateId": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "messageTemplate": {
            "type": "string",
            "nullable": true
          },
          "propertyValues": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": false
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "FeedbackLevel": {
        "enum": [
          "None",
          "Progress",
          "Debug",
          "Information",
          "Warning",
          "Error",
          "ExecutionKeepAlive",
          "ProgressAndDebug",
          "ProgressAndInformation",
          "ProgressAndWarning",
          "ProgressAndError"
        ],
        "type": "string"
      },
      "IdSelectorDefinition": {
        "required": [
          "actions",
          "identifier"
        ],
        "type": "object",
        "properties": {
          "identifier": {
            "minLength": 1,
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "actions": {
            "minLength": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActionId"
            }
          },
          "name": {
            "maxLength": 100,
            "minLength": 0,
            "type": "string",
            "nullable": true
          },
          "description": {
            "maxLength": 1024,
            "minLength": 0,
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Link": {
        "required": [
          "href",
          "method",
          "relation"
        ],
        "type": "object",
        "properties": {
          "relation": {
            "type": "string"
          },
          "href": {
            "type": "string",
            "format": "uri"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "method": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "LusidProblemDetails": {
        "required": [
          "code",
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "errorDetails": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "nullable": true
          },
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          },
          "extensions": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": false
            },
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "MultiQueryDefinitionType": {
        "enum": [
          "Instrument",
          "Expiry",
          "CorporateActions",
          "EdiInstrument",
          "EdiInstrumentWriter",
          "Testing",
          "MarketplaceClientLoadHistory",
          "InsightsMetricsEntitlement"
        ],
        "type": "string"
      },
      "ResourceListOfAccessControlledResource": {
        "required": [
          "values"
        ],
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccessControlledResource"
            }
          },
          "href": {
            "type": "string",
            "format": "uri",
            "nullable": true
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "nullable": true
          },
          "nextPage": {
            "type": "string",
            "nullable": true
          },
          "previousPage": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TaskStatus": {
        "enum": [
          "Created",
          "WaitingForActivation",
          "WaitingToRun",
          "Running",
          "WaitingForChildrenToComplete",
          "RanToCompletion",
          "Canceled",
          "Faulted"
        ],
        "type": "string"
      }
    },
    "securitySchemes": {
      "oauth2": {
        "type": "oauth2",
        "description": "OAuth2 Implicit Grant",
        "flows": {
          "implicit": {
            "authorizationUrl": "https://lusid-fbn-ci.okta.com/oauth2/aus49h9b8rQPvouCH2p7/v1/authorize",
            "scopes": {}
          }
        }
      }
    }
  },
  "security": [
    {}
  ],
  "tags": [
    {
      "name": "Application Metadata",
      "description": "Metadata about the application"
    },
    {
      "name": "Current Table/Field Catalog",
      "description": "Shows Table and Field level information on Providers that are currently running that you have access to."
    },
    {
      "name": "Historically Executed Queries",
      "description": "Shows queries executed at some point and details about them"
    },
    {
      "name": "Multi-Query Execution",
      "description": "This executes a series of internally defined LuminesceSql statements in the background"
    },
    {
      "name": "Sql Background Execution",
      "description": "This executes LuminesceSql and allows monitoring its completion"
    },
    {
      "name": "Sql Execution",
      "description": "This executes LuminesceSql synchronously, allows for returning the resulting data in various formats and for pretty-printing of sql."
    }
  ],
  "x-tagGroups": {
    "name": "API",
    "tags": [
      "Application Metadata",
      "Current Table/Field Catalog",
      "Historically Executed Queries",
      "Multi-Query Execution",
      "Sql Background Execution",
      "Sql Execution"
    ]
  }
}
